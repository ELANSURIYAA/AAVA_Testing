Session: 1772115297927663400_DB2_Sales_Performance.txt

1. Script Overview:
The script is an advanced analytical query for the Sales Performance database. It generates customer segmentation, sales trends, and product performance metrics by combining transactional and dimensional data. The primary business objective is to identify top-performing customers, segment them by value and behavior, and provide actionable insights for sales and marketing teams. It leverages multiple CTEs to prepare dimensions, analyze sales, calculate lifetime value, rank customers, and output the top 100 per segment.

2. Complexity Metrics:

| Metric                | Value                                                                                  |
|-----------------------|----------------------------------------------------------------------------------------|
| Number of Lines       | 109                                                                                    |
| Tables Used           | 3 (customer_master, sales_transactions, product_master)                                |
| Joins                 | 6 (All INNER JOINs via CTEs; explicit JOINs: customer_dimension→sales_analysis, customer_dimension→customer_lifetime_value, customer_segmentation→product_performance, customer_segmentation→regional_performance, customer_segmentation→seasonal_sales, comprehensive_performance→product_performance, comprehensive_performance→regional_performance, comprehensive_performance→seasonal_sales) |
| Temporary Tables      | 10 (CTEs: customer_dimension, sales_analysis, product_performance, seasonal_sales, regional_performance, customer_lifetime_value, customer_segmentation, comprehensive_performance, ranked_customers) |
| Aggregate Functions   | 18 (COUNT, SUM, AVG, MIN, MAX, ROUND, DENSE_RANK, PERCENT_RANK, ROW_NUMBER)            |
| DML Statements        | SELECT: 10 (main query + CTEs), INSERT/UPDATE/DELETE/CALL/LOCK/EXPORT/IMPORT: 0        |
| Conditional Logic     | 7 (CASE statements: age_group, customer_segment, purchase_behavior, customer_potential, customer_value_score, months_since_last_purchase, category_diversity_index) |

3. Syntax Differences:
- YEAR(order_date), MONTH(order_date): DB2 syntax, Oracle uses EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date)
- DAYS(CURRENT_DATE) - DAYS(sa.last_purchase_date): DB2 date arithmetic, Oracle uses MONTHS_BETWEEN or TRUNC/CURRENT_DATE - last_purchase_date
- INT(): DB2 casting, Oracle uses TRUNC or CAST
- NULLIF(): Supported in both, but check for subtle differences
- FETCH FIRST N ROWS ONLY: Not used, but Oracle uses ROWNUM or FETCH FIRST syntax
- ROUND(): Supported in both, but argument order may differ
- DENSE_RANK(), PERCENT_RANK(), ROW_NUMBER(): Supported in Oracle, but syntax may differ slightly
- Partitioning in ROW_NUMBER: Supported in Oracle, but check for syntax
- CTEs (WITH): Supported in Oracle 12c+, but older versions may require inline views

Number of syntax differences: 6

4. Manual Adjustments:
- Replace YEAR(order_date), MONTH(order_date) with EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date)
- Replace DAYS(CURRENT_DATE) - DAYS(last_purchase_date) with MONTHS_BETWEEN(CURRENT_DATE, last_purchase_date) or TRUNC(CURRENT_DATE) - TRUNC(last_purchase_date)
- Replace INT() with TRUNC() or CAST() in Oracle
- Ensure ROUND() arguments are compatible
- Ensure window functions (DENSE_RANK, PERCENT_RANK, ROW_NUMBER) use Oracle syntax (OVER, PARTITION BY, ORDER BY)
- CTEs: If Oracle version <12c, refactor as inline views
- CASE statements: Syntax is compatible, but ensure Oracle's CASE expression is used

Strategies for unsupported constructs:
- Recursive SQL: Not present, but if required, use Oracle's CONNECT BY or recursive CTEs (12c+)
- FETCH FIRST N ROWS ONLY: Use FETCH FIRST N ROWS ONLY (Oracle 12c+) or ROWNUM <= N

5. Conversion Complexity:
Complexity Score: 38/100
- Moderate complexity due to multiple CTEs, window functions, and DB2-specific date functions
- High-complexity areas: Date arithmetic (DAYS, INT), window functions (ranking, percentiles), CTE chaining
- No recursive CTEs or procedural logic present

6. Optimization Techniques:
- Leverage Oracle Exadata parallelism: Use PARALLEL hints for large scans
- Partition sales_transactions by order_date for seasonal analysis
- Index customer_id, product_category, state for join and aggregation performance
- Use Oracle optimizer hints (e.g., /*+ PARALLEL */, /*+ INDEX */) for critical queries
- Refactor CTEs as inline views if Oracle version <12c
- Consider materialized views for heavy aggregation (e.g., sales_analysis, product_performance)
- Use EXADATA Smart Scan for large table scans

Recommendation: Refactor
- Minimal structural changes required; main adjustments are function and syntax replacements
- No need to rebuild logic, as Oracle supports CTEs, window functions, and aggregates
- Justification: The script is well-structured, modular, and compatible with Oracle's analytical features. Refactoring ensures minimal disruption and preserves business logic.

7. apiCost: 0.0437 USD

---
Complete content of DB2_Sales_Performance.txt:

WITH 
-- Customer Dimension Preparation
customer_dimension AS (
    SELECT 
        customer_id,
        first_name,
        last_name,
        email,
        state,
        CASE 
            WHEN age BETWEEN 18 AND 25 THEN '18-25'
            WHEN age BETWEEN 26 AND 35 THEN '26-35'
            WHEN age BETWEEN 36 AND 45 THEN '36-45'
            WHEN age BETWEEN 46 AND 55 THEN '46-55'
            ELSE '55+'
        END AS age_group,
        registration_date
    FROM customer_master
),

-- Sales Transaction Analysis
sales_analysis AS (
    SELECT 
        customer_id,
        COUNT(DISTINCT order_id) AS total_orders,
        SUM(total_sale_amount) AS total_revenue,
        AVG(total_sale_amount) AS average_order_value,
        COUNT(DISTINCT product_category) AS unique_product_categories,
        MIN(order_date) AS first_purchase_date,
        MAX(order_date) AS last_purchase_date,
        SUM(quantity_sold) AS total_units_sold
    FROM sales_transactions
    GROUP BY customer_id
),

-- Product Performance Analysis
product_performance AS (
    SELECT 
        product_category,
        SUM(total_sale_amount) AS category_total_revenue,
        SUM(quantity_sold) AS category_total_units,
        AVG(unit_price) AS average_unit_price,
        COUNT(DISTINCT product_id) AS unique_products
    FROM sales_transactions
    GROUP BY product_category
),

-- Seasonal Sales Trend
seasonal_sales AS (
    SELECT 
        YEAR(order_date) AS sales_year,
        MONTH(order_date) AS sales_month,
        SUM(total_sale_amount) AS monthly_revenue,
        SUM(quantity_sold) AS monthly_units_sold,
        COUNT(DISTINCT customer_id) AS active_customers
    FROM sales_transactions
    GROUP BY YEAR(order_date), MONTH(order_date)
),

-- Regional Performance
regional_performance AS (
    SELECT 
        state,
        SUM(total_sale_amount) AS state_total_revenue,
        COUNT(DISTINCT customer_id) AS state_total_customers,
        AVG(total_sale_amount) AS state_average_order_value
    FROM sales_transactions
    GROUP BY state
),

-- Customer Lifetime Value Calculation
customer_lifetime_value AS (
    SELECT 
        customer_id,
        total_revenue,
        total_orders,
        CASE 
            WHEN total_revenue > 10000 THEN 'Premium'
            WHEN total_revenue BETWEEN 5000 AND 10000 THEN 'Gold'
            WHEN total_revenue BETWEEN 1000 AND 5000 THEN 'Silver'
            ELSE 'Bronze'
        END AS customer_segment,
        ROUND(
            (total_revenue / NULLIF(total_orders, 0)) * 
            CASE 
                WHEN total_orders > 10 THEN 1.5
                WHEN total_orders > 5 THEN 1.2
                ELSE 1
            END,
            2
        ) AS customer_value_score
    FROM sales_analysis
),

-- Advanced Customer Segmentation
customer_segmentation AS (
    SELECT 
        cd.customer_id,
        cd.first_name,
        cd.last_name,
        cd.age_group,
        cd.state,
        sa.total_orders,
        sa.total_revenue,
        sa.average_order_value,
        sa.unique_product_categories,
        clv.customer_segment,
        clv.customer_value_score,

        -- Performance Ranking
        DENSE_RANK() OVER (ORDER BY sa.total_revenue DESC) AS revenue_rank,
        PERCENT_RANK() OVER (ORDER BY sa.total_orders) AS order_frequency_percentile,

        -- Purchase Behavior Indicators
        CASE 
            WHEN sa.total_orders = 1 THEN 'One-time Buyer'
            WHEN sa.total_orders BETWEEN 2 AND 5 THEN 'Occasional Buyer'
            WHEN sa.total_orders > 5 THEN 'Frequent Buyer'
        END AS purchase_behavior,

        -- Recency Calculation (equivalent of MONTHS_BETWEEN)
        INT(DAYS(CURRENT_DATE) - DAYS(sa.last_purchase_date)) / 30 AS months_since_last_purchase,

        -- Cross-Category Engagement
        ROUND(
            sa.unique_product_categories / NULLIF(sa.total_orders, 0),
            2
        ) AS category_diversity_index
    FROM customer_dimension cd
    JOIN sales_analysis sa ON cd.customer_id = sa.customer_id
    JOIN customer_lifetime_value clv ON cd.customer_id = clv.customer_id
),

-- Comprehensive Performance Metrics
comprehensive_performance AS (
    SELECT 
        cs.*,
        pp.product_category AS top_category,
        pp.category_total_revenue,
        rp.state_total_revenue,
        ss.monthly_revenue AS recent_monthly_revenue,

        -- Advanced Performance Scoring
        ROUND(
            (cs.total_revenue / 1000) * 0.4 +
            (cs.total_orders * 5) * 0.3 +
            (cs.unique_product_categories * 10) * 0.3,
            2
        ) AS comprehensive_performance_score
    FROM customer_segmentation cs
    JOIN product_performance pp ON 1=1
    JOIN regional_performance rp ON cs.state = rp.state
    JOIN seasonal_sales ss ON 1=1
),

-- Add row numbers for filtering top 100 per segment
ranked_customers AS (
    SELECT 
        cp.*,
        ROW_NUMBER() OVER (PARTITION BY customer_segment ORDER BY comprehensive_performance_score DESC) AS segment_rank
    FROM comprehensive_performance cp
    WHERE 
        total_revenue > 1000 AND
        total_orders > 2
)

-- Final Output
SELECT 
    customer_id,
    first_name,
    last_name,
    age_group,
    state,
    customer_segment,
    total_orders,
    total_revenue,
    average_order_value,
    unique_product_categories,
    top_category,
    category_total_revenue,
    state_total_revenue,
    recent_monthly_revenue,
    revenue_rank,
    order_frequency_percentile,
    purchase_behavior,
    months_since_last_purchase,
    category_diversity_index,
    customer_value_score,
    comprehensive_performance_score,

    CASE 
        WHEN comprehensive_performance_score > 80 THEN 'High Potential'
        WHEN comprehensive_performance_score BETWEEN 50 AND 80 THEN 'Medium Potential'
        ELSE 'Low Potential'
    END AS customer_potential

FROM ranked_customers
WHERE segment_rank <= 100
ORDER BY comprehensive_performance_score DESC, total_revenue DESC;