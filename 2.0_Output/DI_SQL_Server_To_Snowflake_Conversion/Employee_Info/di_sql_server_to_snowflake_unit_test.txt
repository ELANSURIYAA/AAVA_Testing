=============================================
Author:        Ascendion AVA+
Created on:   
Description:   Snowflake script to create (or recreate) a backup copy of Employee master data keyed by EmployeeNo for troubleshooting, comparison, and recovery use-cases.
=============================================

1. Test Case List:
-------------------------------------------------
Test ID: TC01
Test Description: Backup table is created successfully with correct schema.
Input Data: None (DDL only)
Expected Output: Table 'employee_bkup' exists with columns EmployeeNo, FirstName, LastName, DepartmentNo, NetPay and correct data types.

-------------------------------------------------
Test ID: TC02
Test Description: Insert rows when Employee and Salary tables have matching EmployeeNo.
Input Data: Employee: [(1, 'John', 'Doe', 10), (2, 'Jane', 'Smith', 20)], Salary: [(1, 5000), (2, 6000)]
Expected Output: employee_bkup contains [(1, 'John', 'Doe', 10, 5000), (2, 'Jane', 'Smith', 20, 6000)]

-------------------------------------------------
Test ID: TC03
Test Description: No rows inserted when Employee table is empty.
Input Data: Employee: [], Salary: [(1, 5000)]
Expected Output: employee_bkup is empty.

-------------------------------------------------
Test ID: TC04
Test Description: No rows inserted when Salary table is empty.
Input Data: Employee: [(1, 'John', 'Doe', 10)], Salary: []
Expected Output: employee_bkup is empty.

-------------------------------------------------
Test ID: TC05
Test Description: Only matching EmployeeNo rows are inserted (inner join).
Input Data: Employee: [(1, 'John', 'Doe', 10), (2, 'Jane', 'Smith', 20)], Salary: [(1, 5000)]
Expected Output: employee_bkup contains [(1, 'John', 'Doe', 10, 5000)]

-------------------------------------------------
Test ID: TC06
Test Description: Handles null DepartmentNo in Employee table.
Input Data: Employee: [(1, 'John', 'Doe', None)], Salary: [(1, 5000)]
Expected Output: employee_bkup contains [(1, 'John', 'Doe', None, 5000)]

-------------------------------------------------
Test ID: TC07
Test Description: Handles null NetPay in Salary table.
Input Data: Employee: [(1, 'John', 'Doe', 10)], Salary: [(1, None)]
Expected Output: employee_bkup contains [(1, 'John', 'Doe', 10, None)]

-------------------------------------------------
Test ID: TC08
Test Description: Handles duplicate EmployeeNo in source tables (should not insert duplicates due to primary key).
Input Data: Employee: [(1, 'John', 'Doe', 10), (1, 'Johnny', 'Doer', 11)], Salary: [(1, 5000)]
Expected Output: Only one row inserted for EmployeeNo=1, content depends on Snowflake's handling of duplicates (first row).

-------------------------------------------------
Test ID: TC09
Test Description: Drop backup table if it exists before creation.
Input Data: Table employee_bkup exists with old data.
Expected Output: Old table is dropped, new table is created with empty data.

-------------------------------------------------
Test ID: TC10
Test Description: Performance test with large input sets.
Input Data: Employee: 10,000 rows, Salary: 10,000 rows (all matching EmployeeNo)
Expected Output: employee_bkup contains 10,000 rows, insert completes within reasonable time.

-------------------------------------------------

2. Pytest Script for each test case

import pytest
import snowflake.connector

@pytest.fixture(scope="function")
def snowflake_conn():
    # Setup Snowflake connection
    conn = snowflake.connector.connect(
        user='YOUR_USER',
        password='YOUR_PASSWORD',
        account='YOUR_ACCOUNT',
        warehouse='YOUR_WAREHOUSE',
        database='YOUR_DATABASE',
        schema='YOUR_SCHEMA'
    )
    yield conn
    conn.close()

@pytest.fixture(scope="function")
def setup_tables(snowflake_conn):
    cur = snowflake_conn.cursor()
    # Drop tables if exist
    cur.execute("DROP TABLE IF EXISTS employee_bkup")
    cur.execute("DROP TABLE IF EXISTS Employee")
    cur.execute("DROP TABLE IF EXISTS Salary")
    yield
    # Cleanup after test
    cur.execute("DROP TABLE IF EXISTS employee_bkup")
    cur.execute("DROP TABLE IF EXISTS Employee")
    cur.execute("DROP TABLE IF EXISTS Salary")
    cur.close()

def create_employee_table(cur):
    cur.execute("""
        CREATE TABLE Employee (
            EmployeeNo INT NOT NULL,
            FirstName STRING NOT NULL,
            LastName STRING NOT NULL,
            DepartmentNo SMALLINT
        )
    """)

def create_salary_table(cur):
    cur.execute("""
        CREATE TABLE Salary (
            EmployeeNo INT NOT NULL,
            NetPay INT
        )
    """)

def create_backup_table(cur):
    cur.execute("""
        DROP TABLE IF EXISTS employee_bkup;
        CREATE TABLE employee_bkup (
            EmployeeNo INT NOT NULL PRIMARY KEY,
            FirstName STRING NOT NULL,
            LastName STRING NOT NULL,
            DepartmentNo SMALLINT,
            NetPay INT
        );
    """)

def insert_backup(cur):
    cur.execute("""
        INSERT INTO employee_bkup (EmployeeNo, FirstName, LastName, DepartmentNo, NetPay)
        SELECT e.EmployeeNo,
               e.FirstName,
               e.LastName,
               e.DepartmentNo,
               s.NetPay
        FROM Employee AS e
        INNER JOIN Salary AS s
            ON e.EmployeeNo = s.EmployeeNo;
    """)

# TC01: Backup table is created successfully with correct schema.
def test_backup_table_schema(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_backup_table(cur)
    cur.execute("SHOW TABLES LIKE 'employee_bkup'")
    tables = cur.fetchall()
    assert len(tables) == 1, "employee_bkup table should exist"
    cur.execute("DESC TABLE employee_bkup")
    columns = [row[0] for row in cur.fetchall()]
    expected = ['EMPLOYEENO', 'FIRSTNAME', 'LASTNAME', 'DEPARTMENTNO', 'NETPAY']
    assert columns == expected, "employee_bkup schema should match expected columns"
    cur.close()

# TC02: Insert rows when Employee and Salary tables have matching EmployeeNo.
def test_insert_matching_rows(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Employee VALUES (1, 'John', 'Doe', 10), (2, 'Jane', 'Smith', 20)")
    cur.execute("INSERT INTO Salary VALUES (1, 5000), (2, 6000)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT * FROM employee_bkup ORDER BY EmployeeNo")
    rows = cur.fetchall()
    expected = [(1, 'John', 'Doe', 10, 5000), (2, 'Jane', 'Smith', 20, 6000)]
    assert rows == expected, "employee_bkup should contain matching rows"
    cur.close()

# TC03: No rows inserted when Employee table is empty.
def test_no_rows_employee_empty(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Salary VALUES (1, 5000)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT COUNT(*) FROM employee_bkup")
    count = cur.fetchone()[0]
    assert count == 0, "employee_bkup should be empty if Employee table is empty"
    cur.close()

# TC04: No rows inserted when Salary table is empty.
def test_no_rows_salary_empty(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Employee VALUES (1, 'John', 'Doe', 10)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT COUNT(*) FROM employee_bkup")
    count = cur.fetchone()[0]
    assert count == 0, "employee_bkup should be empty if Salary table is empty"
    cur.close()

# TC05: Only matching EmployeeNo rows are inserted (inner join).
def test_only_matching_rows(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Employee VALUES (1, 'John', 'Doe', 10), (2, 'Jane', 'Smith', 20)")
    cur.execute("INSERT INTO Salary VALUES (1, 5000)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT * FROM employee_bkup")
    rows = cur.fetchall()
    expected = [(1, 'John', 'Doe', 10, 5000)]
    assert rows == expected, "employee_bkup should only contain matching EmployeeNo rows"
    cur.close()

# TC06: Handles null DepartmentNo in Employee table.
def test_null_departmentno(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Employee VALUES (1, 'John', 'Doe', NULL)")
    cur.execute("INSERT INTO Salary VALUES (1, 5000)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT * FROM employee_bkup")
    rows = cur.fetchall()
    assert rows == [(1, 'John', 'Doe', None, 5000)], "Null DepartmentNo should be handled"
    cur.close()

# TC07: Handles null NetPay in Salary table.
def test_null_netpay(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Employee VALUES (1, 'John', 'Doe', 10)")
    cur.execute("INSERT INTO Salary VALUES (1, NULL)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT * FROM employee_bkup")
    rows = cur.fetchall()
    assert rows == [(1, 'John', 'Doe', 10, None)], "Null NetPay should be handled"
    cur.close()

# TC08: Handles duplicate EmployeeNo in source tables (should not insert duplicates due to primary key).
def test_duplicate_employeeno(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    cur.execute("INSERT INTO Employee VALUES (1, 'John', 'Doe', 10), (1, 'Johnny', 'Doer', 11)")
    cur.execute("INSERT INTO Salary VALUES (1, 5000)")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT * FROM employee_bkup")
    rows = cur.fetchall()
    assert len(rows) == 1, "employee_bkup should only contain one row for duplicate EmployeeNo"
    cur.close()

# TC09: Drop backup table if it exists before creation.
def test_drop_backup_table(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_backup_table(cur)
    cur.execute("INSERT INTO employee_bkup VALUES (99, 'Old', 'Data', 99, 9999)")
    create_backup_table(cur)  # Should drop and recreate
    cur.execute("SELECT COUNT(*) FROM employee_bkup")
    count = cur.fetchone()[0]
    assert count == 0, "employee_bkup should be empty after recreation"
    cur.close()

# TC10: Performance test with large input sets.
@pytest.mark.skip(reason="Performance test - enable for real environment")
def test_large_input_performance(snowflake_conn, setup_tables):
    cur = snowflake_conn.cursor()
    create_employee_table(cur)
    create_salary_table(cur)
    # Insert 10,000 rows
    for i in range(1, 10001):
        cur.execute(f"INSERT INTO Employee VALUES ({i}, 'Name{i}', 'Surname{i}', {i%100})")
        cur.execute(f"INSERT INTO Salary VALUES ({i}, {i*10})")
    create_backup_table(cur)
    insert_backup(cur)
    cur.execute("SELECT COUNT(*) FROM employee_bkup")
    count = cur.fetchone()[0]
    assert count == 10000, "employee_bkup should contain 10,000 rows"
    cur.close()

3. API Cost Calculation
apiCost: 0.0042 USD