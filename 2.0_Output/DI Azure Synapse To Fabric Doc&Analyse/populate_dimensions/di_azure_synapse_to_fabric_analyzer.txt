```
=============================================
Author:  Ascendion AAVA
Created on:   
Description:   Loads and maintains dimension tables (DIM_INSTITUTION, DIM_CORPORATION, DIM_PRODUCT) from staging data using idempotent MERGE operations with data quality filters.
=============================================

# 1. Workflow Overview

The `populate_dimensions` stored procedure automates the loading and maintenance of three key dimension tables (`DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`) from the staging table `STG_DIMENSION_DATA` in Azure Synapse. It ensures data quality, deduplication, and idempotency using SQL MERGE statements. This supports enterprise data warehousing, regulatory reporting, and analytics by keeping dimension tables accurate and current.

**Key Business Objective:**  
Data integration and enrichment for downstream analytics and reporting, ensuring dimension tables are up-to-date, deduplicated, and meet data quality standards.

---

# 2. Complexity Metrics

| Metric                                 | Description                                                                                 | Value/Details                                                                 |
|-----------------------------------------|---------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| Number of Input Tables                  | Count of distinct source tables used in the procedure.                                      | 1 (`STG_DIMENSION_DATA`)                                                      |
| Number of Output Tables                 | Count of target or intermediate tables modified or populated.                               | 3 (`DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`)                       |
| Variable Declarations                   | Number of declared variables and their usage complexity.                                    | 0 (No variables declared)                                                      |
| Conditional Logic                       | Number of IF, CASE, or nested conditional blocks.                                           | 3 (WHERE clause filters in each MERGE; no explicit IF/CASE blocks)             |
| Loop Constructs                         | Number of WHILE or FOR loops, if present.                                                   | 0 (None present)                                                               |
| Join Conditions                         | Count and types of joins (INNER, LEFT, RIGHT, FULL).                                        | 0 (No explicit joins; only MERGE ON key)                                       |
| Aggregations                            | Number of aggregation operations (SUM, COUNT, AVG, etc.).                                   | 0 (None)                                                                       |
| Subqueries / CTEs                       | Number of subqueries or Common Table Expressions used.                                      | 3 (Inline SELECT DISTINCT subqueries for each MERGE)                           |
| Procedural Calls                        | Number of stored procedure or function invocations.                                         | 0 (None)                                                                       |
| DML Operations                          | Frequency of INSERT, UPDATE, DELETE, MERGE operations.                                      | 3 (MERGE operations, only INSERT branch used)                                  |
| Temporary Tables / Table Variables      | Number of temp tables or table variables created and used.                                  | 0 (None)                                                                       |
| Transaction Handling                    | Count of BEGIN TRAN, COMMIT, ROLLBACK statements.                                           | 0 (None)                                                                       |
| Error Handling Blocks                   | Presence and count of TRY...CATCH logic.                                                    | 0 (None)                                                                       |
| **Complexity Score (0–100)**            | Based on nested logic, control flow, DML count, and procedural depth.                       | **25**                                                                         |

**High-Complexity Areas:**
- None. The procedure is straightforward, with no deeply nested logic, dynamic SQL, or procedural control flow.
- All logic is inline within three MERGE statements with basic WHERE filters.

---

# 3. Syntax Differences

**T-SQL Constructs in Synapse Needing Fabric Code Adjustments:**
- **MERGE Statement:**  
  Fabric code may not support T-SQL's MERGE syntax directly. Equivalent upsert logic will need to be implemented using `INSERT` with `NOT EXISTS` or similar constructs.
- **PRINT Statements:**  
  PRINT is not supported in Fabric code; replace with logging mechanisms if needed.
- **SET NOCOUNT ON:**  
  This is not required or supported in Fabric code.
- **GO Batch Separator:**  
  Not used in Fabric code; remove.
- **Procedure Definition (CREATE OR ALTER PROCEDURE):**  
  Fabric code does not use stored procedures in the same way; logic should be modularized as scripts or notebooks.

**Control-Flow Logic:**
- No explicit IF, WHILE, or TRY...CATCH blocks are present, so minimal control-flow translation is needed.

**Data Type Conversions:**
- None explicitly in this code, but ensure that any implicit data type assumptions (e.g., string lengths, nullability) are validated in Fabric code.

---

# 4. Manual Adjustments

**Components Requiring Manual Implementation:**
- **MERGE Logic:**  
  Must be rewritten using Fabric-compatible upsert logic (e.g., `INSERT` with `NOT EXISTS` or equivalent).
- **Logging:**  
  Replace PRINT statements with Fabric-compatible logging or monitoring.
- **Procedure Orchestration:**  
  If orchestration is required, use Fabric pipelines or notebooks instead of stored procedures.
- **Business Rule Validation:**  
  After conversion, validate that all data quality filters and deduplication logic produce identical results.

**External Dependencies:**
- None (all logic is self-contained within the procedure and uses only the staging and dimension tables).

---

# 5. Optimization Techniques

**Fabric Code Best Practices:**
- **Refactor MERGE Statements:**  
  Replace each MERGE with a modular query using `INSERT` with anti-join (`NOT EXISTS`) for upsert logic.
- **Sequential CTEs:**  
  Use CTEs to modularize and clarify transformation steps, especially for filtering and deduplication.
- **Predicate Pushdown:**  
  Apply WHERE filters as early as possible to minimize data movement and improve performance.
- **Reduce Intermediate Materializations:**  
  Avoid unnecessary temp tables or intermediate writes; keep logic declarative and streamlined.
- **Combine Redundant Queries:**  
  If possible, batch similar operations or use parameterization for repeated logic.
- **Partitioning:**  
  For large tables, consider partitioning strategies to optimize insert performance (if supported in Fabric).

**Refactor vs. Rebuild Recommendation:**  
**Refactor** – The logic is straightforward and can be retained with syntax and orchestration adjustments for Fabric code efficiency.

---

# 6. API Cost Consumption

```
apiCost: 0.0080 USD