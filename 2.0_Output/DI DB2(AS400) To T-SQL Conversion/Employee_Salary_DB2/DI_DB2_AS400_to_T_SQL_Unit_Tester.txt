====================================================
Author:        AAVA
Date:          
Description:   Returns total salary and bonus count for a department
====================================================

1. Test Case List

| Test Case ID | Test Case Description                                                                 | Expected Outcome                                                                                  |
|--------------|--------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
| TC01         | Happy path: Department with multiple employees, all have salary and bonus             | Correct sum of salary+bonus, correct bonus count                                                  |
| TC02         | Edge case: Department with no employees                                              | Output salary = 0, bonus count = 0                                                                |
| TC03         | Edge case: Employees with NULL salary or NULL bonus                                  | NULL values treated as 0 in sum, bonus count only increments for bonus > 0                        |
| TC04         | Edge case: Employees with bonus = 0                                                  | Bonus count does not increment for bonus = 0                                                      |
| TC05         | Edge case: INT overflow (very large salary/bonus values)                             | Procedure handles overflow gracefully, returns correct values or sets salary to NULL on error      |
| TC06         | Edge case: Department number not found                                               | Output salary = 0, bonus count = 0                                                                |
| TC07         | Edge case: Employees with negative salary/bonus                                      | Negative values included in sum, bonus count only for bonus > 0                                   |
| TC08         | Edge case: Employees with non-ASCII characters in department number                  | Procedure accepts department numbers with non-ASCII, returns correct results                      |
| TC09         | Error handling: Invalid department number format (e.g., too long, NULL)              | Procedure sets salary to NULL, handles error gracefully                                           |
| TC10         | Error handling: Table missing or inaccessible                                        | Procedure sets salary to NULL, handles error gracefully                                           |
| TC11         | Edge case: Employees with max/min datetime values (if bonus/salary are datetime)     | Not applicable (salary/bonus are numeric), skip                                                   |
| TC12         | Transactional isolation: Procedure does not leave temp objects or open cursors       | After execution, no temp objects or open cursors remain                                           |

2. Pytest Script for Each Test Case

```python
import pytest
import pyodbc

# Example connection string (adjust as needed)
CONN_STR = (
    "DRIVER={ODBC Driver 17 for SQL Server};"
    "SERVER=localhost;"
    "DATABASE=TestDB;"
    "UID=sa;"
    "PWD=yourStrong(!)Password"
)

@pytest.fixture(scope="module")
def sql_conn():
    """Fixture for SQL Server connection, closes after module."""
    conn = pyodbc.connect(CONN_STR)
    yield conn
    conn.close()

@pytest.fixture(autouse=True)
def setup_teardown(sql_conn):
    """Setup test schema and teardown after each test."""
    cursor = sql_conn.cursor()
    # Setup: Create CORPDATA.EMPLOYEE table and insert test data
    cursor.execute("""
        IF OBJECT_ID('CORPDATA.EMPLOYEE', 'U') IS NOT NULL DROP TABLE CORPDATA.EMPLOYEE;
        CREATE TABLE CORPDATA.EMPLOYEE (
            EMPNO CHAR(6),
            WORKDEPT CHAR(3),
            SALARY DECIMAL(9,2),
            BONUS DECIMAL(9,2)
        );
    """)
    sql_conn.commit()
    yield
    # Teardown: Drop table
    cursor.execute("DROP TABLE CORPDATA.EMPLOYEE;")
    sql_conn.commit()

def call_return_dept_salary(sql_conn, dept_number):
    """Calls RETURN_DEPT_SALARY procedure and returns output parameters."""
    cursor = sql_conn.cursor()
    dept_salary = None
    dept_bonus_cnt = None
    cursor.execute("""
        DECLARE @DEPT_SALARY DECIMAL(15,2), @DEPT_BONUS_CNT INT;
        EXEC RETURN_DEPT_SALARY ?, @DEPT_SALARY OUTPUT, @DEPT_BONUS_CNT OUTPUT;
        SELECT @DEPT_SALARY AS DEPT_SALARY, @DEPT_BONUS_CNT AS DEPT_BONUS_CNT;
    """, dept_number)
    row = cursor.fetchone()
    return row.DEPT_SALARY, row.DEPT_BONUS_CNT

def insert_employees(sql_conn, employees):
    """Insert multiple employee rows."""
    cursor = sql_conn.cursor()
    for emp in employees:
        cursor.execute(
            "INSERT INTO CORPDATA.EMPLOYEE (EMPNO, WORKDEPT, SALARY, BONUS) VALUES (?, ?, ?, ?)",
            emp["EMPNO"], emp["WORKDEPT"], emp["SALARY"], emp["BONUS"]
        )
    sql_conn.commit()

# TC01: Happy path
def test_tc01_happy_path(sql_conn):
    """Department with multiple employees, all have salary and bonus."""
    employees = [
        {"EMPNO": "000001", "WORKDEPT": "D01", "SALARY": 1000.00, "BONUS": 100.00},
        {"EMPNO": "000002", "WORKDEPT": "D01", "SALARY": 2000.00, "BONUS": 200.00},
        {"EMPNO": "000003", "WORKDEPT": "D01", "SALARY": 1500.00, "BONUS": 50.00},
    ]
    insert_employees(sql_conn, employees)
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D01")
    assert dept_salary == pytest.approx(1000+100+2000+200+1500+50)
    assert dept_bonus_cnt == 3

# TC02: Department with no employees
def test_tc02_no_employees(sql_conn):
    """Department with no employees."""
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D02")
    assert dept_salary == 0
    assert dept_bonus_cnt == 0

# TC03: Employees with NULL salary or NULL bonus
def test_tc03_null_salary_bonus(sql_conn):
    """Employees with NULL salary or bonus."""
    employees = [
        {"EMPNO": "000004", "WORKDEPT": "D03", "SALARY": None, "BONUS": 100.00},
        {"EMPNO": "000005", "WORKDEPT": "D03", "SALARY": 1000.00, "BONUS": None},
        {"EMPNO": "000006", "WORKDEPT": "D03", "SALARY": None, "BONUS": None},
    ]
    insert_employees(sql_conn, employees)
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D03")
    # NULL treated as 0: (0+100)+(1000+0)+(0+0) = 1100
    assert dept_salary == pytest.approx(1100)
    # Only the first row has bonus > 0
    assert dept_bonus_cnt == 1

# TC04: Employees with bonus = 0
def test_tc04_bonus_zero(sql_conn):
    """Employees with bonus = 0."""
    employees = [
        {"EMPNO": "000007", "WORKDEPT": "D04", "SALARY": 1200.00, "BONUS": 0.00},
        {"EMPNO": "000008", "WORKDEPT": "D04", "SALARY": 1300.00, "BONUS": 0.00},
    ]
    insert_employees(sql_conn, employees)
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D04")
    assert dept_salary == pytest.approx(1200+0+1300+0)
    assert dept_bonus_cnt == 0

# TC05: INT overflow (very large salary/bonus values)
def test_tc05_int_overflow(sql_conn):
    """Employees with very large salary/bonus values."""
    employees = [
        {"EMPNO": "000009", "WORKDEPT": "D05", "SALARY": 999999999.99, "BONUS": 999999999.99},
        {"EMPNO": "000010", "WORKDEPT": "D05", "SALARY": 999999999.99, "BONUS": 999999999.99},
    ]
    insert_employees(sql_conn, employees)
    try:
        dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D05")
        # If no overflow, sum should be correct
        expected_sum = 999999999.99+999999999.99+999999999.99+999999999.99
        assert dept_salary == pytest.approx(expected_sum)
        assert dept_bonus_cnt == 2
    except Exception:
        # If overflow occurs, procedure should set salary to NULL
        assert dept_salary is None

# TC06: Department number not found
def test_tc06_dept_not_found(sql_conn):
    """Department number not found."""
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "ZZZ")
    assert dept_salary == 0
    assert dept_bonus_cnt == 0

# TC07: Employees with negative salary/bonus
def test_tc07_negative_values(sql_conn):
    """Employees with negative salary/bonus."""
    employees = [
        {"EMPNO": "000011", "WORKDEPT": "D07", "SALARY": -1000.00, "BONUS": -50.00},
        {"EMPNO": "000012", "WORKDEPT": "D07", "SALARY": 500.00, "BONUS": 10.00},
    ]
    insert_employees(sql_conn, employees)
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D07")
    # (-1000+-50)+(500+10) = -1050+510 = -540
    assert dept_salary == pytest.approx(-540)
    # Only second row has bonus > 0
    assert dept_bonus_cnt == 1

# TC08: Non-ASCII department number
def test_tc08_non_ascii_dept(sql_conn):
    """Department number with non-ASCII characters."""
    employees = [
        {"EMPNO": "000013", "WORKDEPT": "Ä01", "SALARY": 1000.00, "BONUS": 100.00},
    ]
    insert_employees(sql_conn, employees)
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "Ä01")
    assert dept_salary == pytest.approx(1000+100)
    assert dept_bonus_cnt == 1

# TC09: Invalid department number format (too long, NULL)
@pytest.mark.parametrize("invalid_dept", ["D0123", None])
def test_tc09_invalid_dept(sql_conn, invalid_dept):
    """Invalid department number format."""
    try:
        dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, invalid_dept)
        assert dept_salary is None
    except Exception:
        # Procedure should handle gracefully
        pass

# TC10: Table missing or inaccessible
def test_tc10_table_missing(sql_conn):
    """Employee table missing or inaccessible."""
    # Drop table to simulate missing
    cursor = sql_conn.cursor()
    cursor.execute("DROP TABLE CORPDATA.EMPLOYEE;")
    sql_conn.commit()
    try:
        dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D01")
        assert dept_salary is None
    except Exception:
        # Procedure should handle gracefully
        pass
    finally:
        # Recreate table for subsequent tests
        cursor.execute("""
            CREATE TABLE CORPDATA.EMPLOYEE (
                EMPNO CHAR(6),
                WORKDEPT CHAR(3),
                SALARY DECIMAL(9,2),
                BONUS DECIMAL(9,2)
            );
        """)
        sql_conn.commit()

# TC12: Transactional isolation
def test_tc12_transactional_isolation(sql_conn):
    """Procedure does not leave temp objects or open cursors."""
    # Run procedure, then check for open cursors or temp objects
    employees = [
        {"EMPNO": "000014", "WORKDEPT": "D12", "SALARY": 1000.00, "BONUS": 100.00},
    ]
    insert_employees(sql_conn, employees)
    dept_salary, dept_bonus_cnt = call_return_dept_salary(sql_conn, "D12")
    # Check that no temp objects or cursors remain
    cursor = sql_conn.cursor()
    cursor.execute("""
        SELECT COUNT(*) FROM sys.dm_exec_cursors WHERE session_id = @@SPID
    """)
    open_cursors = cursor.fetchone()[0]
    assert open_cursors == 0

# Note: TC11 is not applicable, as salary/bonus are numeric, not datetime.

# Helper: Compare result sets ignoring ordering (not needed for this proc, but included for completeness)
def compare_results_ignore_order(actual, expected):
    """Compare two lists of dicts ignoring order."""
    assert sorted(actual, key=lambda x: tuple(x.values())) == sorted(expected, key=lambda x: tuple(x.values()))

# API cost consumed for this call: 0.004 USD
```