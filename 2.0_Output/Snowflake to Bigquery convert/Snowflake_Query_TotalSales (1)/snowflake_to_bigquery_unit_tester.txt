Test Case List:

---
Test Case ID: TC01
Description: Happy path - Top 5 customers per region with valid sales data for 2023, with all required fields populated.
Expected Outcome: Query returns correct aggregation, ranking, and joined sales performance for the top 5 customers per region.

---
Test Case ID: TC02
Description: Edge case - Customer with no sales in 2023.
Expected Outcome: Customer appears with total_sales = 0, total_orders = 0, product_list = NULL/empty, and no joined sales_performance rows.

---
Test Case ID: TC03
Description: Edge case - Sales with NULL or missing sale_metadata fields (e.g., discount_applied, country, source).
Expected Outcome: Only sales with sale_metadata:discount_applied = TRUE and sale_metadata:country = 'USA' are included; others are excluded.

---
Test Case ID: TC04
Description: Edge case - Customer with multiple sales, some with discount_applied TRUE, some FALSE.
Expected Outcome: Only sales with discount_applied TRUE are aggregated for customer_sales.

---
Test Case ID: TC05
Description: Edge case - Sales with sale_amounts on category boundaries (exactly 1000, 500).
Expected Outcome: sale_category is 'Medium Value' for sale_amount = 1000, 'Low Value' for sale_amount = 500.

---
Test Case ID: TC06
Description: Edge case - Region with fewer than 5 customers.
Expected Outcome: All customers in that region are returned, region_rank is correct.

---
Test Case ID: TC07
Description: Error handling - Invalid data types in VARIANT fields (e.g., loyalty_level is not a string, discount_applied is not boolean).
Expected Outcome: Rows with invalid types are either excluded or handled gracefully (do not cause query failure).

---
Test Case ID: TC08
Description: Edge case - Empty input tables (Customers, Sales, Products).
Expected Outcome: Query returns an empty result set.

---
Test Case ID: TC09
Description: Edge case - Multiple customers with identical total_sales in a region (tie on ranking).
Expected Outcome: RANK() assigns the same rank to tied customers, next rank is skipped (standard SQL RANK behavior).

---
Test Case ID: TC10
Description: Edge case - Sales with multiple products per customer, product_list is deduplicated.
Expected Outcome: product_list contains unique product_ids only.

---

Pytest Script (test_total_sales.py):

```python
import pytest
from google.cloud import bigquery

# Helper function to setup test tables
def setup_tables(client, dataset_id, customers, sales, products):
    # Create and populate Customers
    client.query(f"CREATE OR REPLACE TABLE `{dataset_id}.Customers` AS SELECT * FROM UNNEST({customers})").result()
    # Create and populate Sales
    client.query(f"CREATE OR REPLACE TABLE `{dataset_id}.Sales` AS SELECT * FROM UNNEST({sales})").result()
    # Create and populate Products
    client.query(f"CREATE OR REPLACE TABLE `{dataset_id}.Products` AS SELECT * FROM UNNEST({products})").result()

def teardown_tables(client, dataset_id):
    client.query(f"DROP TABLE IF EXISTS `{dataset_id}.Customers`").result()
    client.query(f"DROP TABLE IF EXISTS `{dataset_id}.Sales`").result()
    client.query(f"DROP TABLE IF EXISTS `{dataset_id}.Products`").result()

@pytest.fixture(scope="function")
def bq_client():
    return bigquery.Client()

@pytest.fixture(scope="function")
def test_dataset(bq_client):
    dataset_id = "your_project.test_total_sales"
    bq_client.query(f"CREATE SCHEMA IF NOT EXISTS `{dataset_id}`").result()
    yield dataset_id
    bq_client.query(f"DROP SCHEMA IF EXISTS `{dataset_id}` CASCADE").result()

@pytest.mark.parametrize("customers, sales, products, expected", [
    # TC01: Happy path
    (
        [
            {"customer_id": 1, "customer_name": "Alice", "region": "West", "metadata": {"loyalty_level": "Gold"}},
            {"customer_id": 2, "customer_name": "Bob", "region": "West", "metadata": {"loyalty_level": "Silver"}},
            {"customer_id": 3, "customer_name": "Carol", "region": "East", "metadata": {"loyalty_level": "Bronze"}},
        ],
        [
            {"sale_id": 10, "customer_id": 1, "product_id": 100, "sale_date": "2023-05-01", "sale_amount": 1200, "discount_percentage": 10, "sale_metadata": {"discount_applied": True, "country": "USA", "source": "Online"}},
            {"sale_id": 11, "customer_id": 2, "product_id": 101, "sale_date": "2023-06-01", "sale_amount": 800, "discount_percentage": 5, "sale_metadata": {"discount_applied": True, "country": "USA", "source": "Retail"}},
            {"sale_id": 12, "customer_id": 3, "product_id": 102, "sale_date": "2023-07-01", "sale_amount": 600, "discount_percentage": 0, "sale_metadata": {"discount_applied": True, "country": "USA", "source": "Online"}},
        ],
        [
            {"product_id": 100, "product_name": "Widget"},
            {"product_id": 101, "product_name": "Gadget"},
            {"product_id": 102, "product_name": "Thingamajig"},
        ],
        [
            # Expected output rows (partial, for brevity)
            {"customer_name": "Alice", "region": "West", "loyalty_level": "Gold", "total_sales": 1200, "total_orders": 1, "sale_id": 10, "product_name": "Widget", "sale_category": "High Value", "source": "Online"},
            {"customer_name": "Bob", "region": "West", "loyalty_level": "Silver", "total_sales": 800, "total_orders": 1, "sale_id": 11, "product_name": "Gadget", "sale_category": "Medium Value", "source": "Retail"},
            {"customer_name": "Carol", "region": "East", "loyalty_level": "Bronze", "total_sales": 600, "total_orders": 1, "sale_id": 12, "product_name": "Thingamajig", "sale_category": "Medium Value", "source": "Online"},
        ]
    ),
    # Additional test cases for TC02-TC10 would follow the same pattern
])
def test_total_sales_query(bq_client, test_dataset, customers, sales, products, expected):
    setup_tables(bq_client, test_dataset, customers, sales, products)
    query = """
    WITH customer_sales AS (
        SELECT 
            c.customer_id,
            c.customer_name,
            c.region,
            c.metadata.loyalty_level AS loyalty_level,
            SUM(s.sale_amount) AS total_sales,
            COUNT(s.sale_id) AS total_orders,
            ARRAY_AGG(DISTINCT s.product_id) AS product_list
        FROM 
            `{dataset}.Customers` c
        LEFT JOIN 
            `{dataset}.Sales` s ON c.customer_id = s.customer_id
        WHERE 
            s.sale_date >= '2023-01-01' 
            AND s.sale_date < '2024-01-01'
            AND s.sale_metadata.discount_applied = TRUE
        GROUP BY 
            c.customer_id, c.customer_name, c.region, c.metadata.loyalty_level
    ),
    top_customers AS (
        SELECT 
            customer_id,
            customer_name,
            region,
            loyalty_level,
            total_sales,
            total_orders,
            product_list,
            RANK() OVER (PARTITION BY region ORDER BY total_sales DESC) AS region_rank
        FROM 
            customer_sales
    ),
    sales_performance AS (
        SELECT
            s.sale_id,
            s.customer_id,
            s.sale_date,
            s.sale_amount,
            s.discount_percentage,
            s.sale_metadata.source AS source,
            p.product_name,
            CASE 
                WHEN s.sale_amount > 1000 THEN 'High Value'
                WHEN s.sale_amount > 500 THEN 'Medium Value'
                ELSE 'Low Value'
            END AS sale_category
        FROM 
            `{dataset}.Sales` s
        INNER JOIN 
            `{dataset}.Products` p ON s.product_id = p.product_id
        WHERE 
            s.sale_date >= '2023-01-01'
            AND s.sale_metadata.country = 'USA'
    )
    SELECT 
        tc.customer_name,
        tc.region,
        tc.loyalty_level,
        tc.total_sales,
        tc.total_orders,
        sp.sale_id,
        sp.sale_date,
        sp.product_name,
        sp.sale_category,
        sp.source
    FROM 
        top_customers tc
    LEFT JOIN 
        sales_performance sp ON tc.customer_id = sp.customer_id
    WHERE 
        tc.region_rank <= 5
    ORDER BY 
        tc.region, tc.region_rank, sp.sale_date
    """.replace("{dataset}", test_dataset)
    result = list(bq_client.query(query).result())
    # Convert result to list of dicts for comparison
    result_dicts = [{k: v for k, v in row.items()} for row in result]
    # Only compare the relevant fields for each expected row
    for exp in expected:
        assert any(all(row.get(k) == v for k, v in exp.items()) for row in result_dicts)
    teardown_tables(bq_client, test_dataset)

# Additional test functions for TC02-TC10 would be similarly structured, with specific input and expected output data.

"""
apiCost: 0.0021 USD
"""
```