Session: customer_purchase_query.txt__kp_no52a

1. Script Overview:
The Hive SQL script analyzes customer purchasing behavior for 2024, aggregating customer data, purchase patterns, product category preferences, and seasonal trends. It segments customers, calculates metrics (lifetime value, frequency, recency), and provides insights into product preferences and seasonal spending. The output supports customer segmentation, targeted marketing, and executive reporting.

2. Complexity Metrics:
- Number of Lines: 84
- Tables Used: 6 (`customers`, `orders`, `regions`, `order_items`, `products`, `product_categories`)
- Joins: 7 total (INNER JOINs and LEFT JOINs; 3 in CTEs, 2 in final SELECT, 2 in CTEs)
- Temporary Tables: 3 (CTEs: `customer_purchase_summary`, `product_category_preferences`, `seasonal_spending_patterns`)
- Aggregate Functions: 11+ (SUM, COUNT, MIN, MAX, AVG, ROUND, NTILE, ROW_NUMBER)
- DML Statements: 1 main SELECT, 3 CTE SELECTs, no INSERT/UPDATE/DELETE/LOAD/EXPORT
- Conditional Logic: 7+ (CASE statements for tiering, category selection, growth calculation)

3. Syntax Differences:
- Partitioning Syntax: No explicit DISTRIBUTE BY, but time-based filtering; BigQuery uses PARTITION BY.
- Window Functions: Hive uses ROW_NUMBER() OVER, NTILE() OVER; BigQuery syntax is similar but may require adjustments.
- Lateral Views & Explode: Not used in this script.
- Data Types: Hive uses STRING, BIGINT, etc.; BigQuery uses STRING, INT64, FLOAT64.
- Date Functions: Hive uses DATEDIFF(), QUARTER(), MONTH(), DAYOFWEEK(); BigQuery equivalents are DATE_DIFF(), EXTRACT(QUARTER FROM ...), EXTRACT(MONTH FROM ...), EXTRACT(DAYOFWEEK FROM ...).
- NULLIF: Supported in BigQuery.
- CASE: Supported in BigQuery.

4. Manual Adjustments:
- Function replacements:
  - DATEDIFF() → DATE_DIFF() in BigQuery.
  - QUARTER(), MONTH(), DAYOFWEEK() → EXTRACT(QUARTER FROM ...), EXTRACT(MONTH FROM ...), EXTRACT(DAYOFWEEK FROM ...).
  - ROW_NUMBER() and NTILE() window functions: Syntax is similar, but ensure OVER clause matches BigQuery requirements.
- Syntax Adjustments:
  - GROUP BY: BigQuery requires all non-aggregated columns in SELECT to be in GROUP BY.
  - LIMIT: Supported in BigQuery.
  - CASE: Supported, but ensure syntax matches.
  - NULLIF: Supported.
- Workarounds for unsupported features:
  - No LATERAL VIEW/EXPLODE present.
  - No DISTRIBUTE BY present.
  - No MAP data types present.
- Data type mapping:
  - Ensure INT/BIGINT → INT64, DECIMAL → FLOAT64/NUMERIC, STRING → STRING.

5. Conversion Complexity:
- Complexity Score: 85/100
- High-complexity areas:
  - Multiple CTEs and joins.
  - Advanced window functions (ROW_NUMBER, NTILE).
  - Date functions and conditional logic.
  - Aggregations and CASE logic.
- Manual adjustments required for date functions, window functions, and GROUP BY syntax.
- No recursive CTEs or LATERAL VIEW/EXPLODE.

6. Optimization Techniques:
- Partitioning & Clustering: Use BigQuery partitioning on `order_date` for the orders table; consider clustering on `customer_id` and `region_id`.
- Query Restructuring: Materialize intermediate results as views or tables for repeated use; optimize join order for cost efficiency.
- Storage Format Adjustments: Store data in BigQuery-native formats (partitioned tables, clustered tables); use compressed formats for external sources.
- Refactor vs. Rebuild Decision: Refactor. The logic can be migrated with moderate syntax changes and function replacements; no major restructuring required. Rebuild only if performance issues arise due to data volume or join complexity.

7. API Cost Estimation:
apiCost: 0.0123

---
Complete file content analyzed:

-- Complex Hive Query for Customer Purchase Pattern Analysis
-- This query analyzes purchasing behavior across regions, demographics, and time periods

WITH customer_purchase_summary AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.age_group,
    c.gender,
    c.region_id,
    r.region_name,
    r.country,
    SUM(o.order_amount) AS total_spent,
    COUNT(DISTINCT o.order_id) AS order_count,
    MIN(o.order_date) AS first_purchase_date,
    MAX(o.order_date) AS last_purchase_date,
    DATEDIFF(MAX(o.order_date), MIN(o.order_date)) AS customer_tenure_days
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN regions r ON c.region_id = r.region_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND o.order_status = 'COMPLETED'
  GROUP BY 
    c.customer_id, 
    c.customer_name,
    c.age_group,
    c.gender,
    c.region_id,
    r.region_name,
    r.country
),

product_category_preferences AS (
  SELECT 
    o.customer_id,
    p.category_id,
    pc.category_name,
    COUNT(DISTINCT o.order_id) AS category_purchase_count,
    SUM(oi.quantity) AS items_purchased,
    SUM(oi.quantity * oi.unit_price) AS category_amount_spent,
    ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY SUM(oi.quantity * oi.unit_price) DESC) AS category_rank
  FROM orders o
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND o.order_status = 'COMPLETED'
  GROUP BY 
    o.customer_id,
    p.category_id,
    pc.category_name
),

seasonal_spending_patterns AS (
  SELECT
    c.customer_id,
    QUARTER(o.order_date) AS quarter,
    MONTH(o.order_date) AS month,
    DAYOFWEEK(o.order_date) AS day_of_week,
    SUM(o.order_amount) AS period_spent,
    COUNT(DISTINCT o.order_id) AS period_order_count,
    AVG(o.order_amount) AS avg_order_value
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND o.order_status = 'COMPLETED'
  GROUP BY
    c.customer_id,
    QUARTER(o.order_date),
    MONTH(o.order_date),
    DAYOFWEEK(o.order_date)
)

SELECT 
  cps.customer_id,
  cps.customer_name,
  cps.age_group,
  cps.gender,
  cps.region_name,
  cps.country,
  cps.total_spent,
  cps.order_count,
  cps.customer_tenure_days,
  -- Calculate customer lifetime value and segmentation
  CASE 
    WHEN cps.total_spent > 10000 THEN 'Platinum'
    WHEN cps.total_spent > 5000 THEN 'Gold'
    WHEN cps.total_spent > 1000 THEN 'Silver'
    ELSE 'Bronze'
  END AS customer_tier,
  -- Calculate purchase frequency metrics
  ROUND(cps.order_count / NULLIF(cps.customer_tenure_days / 30, 0), 2) AS monthly_purchase_frequency,
  -- Get preferred product categories
  MAX(CASE WHEN pcp.category_rank = 1 THEN pcp.category_name ELSE NULL END) AS top_category,
  MAX(CASE WHEN pcp.category_rank = 1 THEN pcp.category_amount_spent ELSE NULL END) AS top_category_spent,
  MAX(CASE WHEN pcp.category_rank = 2 THEN pcp.category_name ELSE NULL END) AS second_category,
  MAX(CASE WHEN pcp.category_rank = 2 THEN pcp.category_amount_spent ELSE NULL END) AS second_category_spent,
  -- Seasonal spending analysis
  MAX(CASE WHEN ssp.quarter = 1 THEN ssp.period_spent ELSE 0 END) AS q1_spent,
  MAX(CASE WHEN ssp.quarter = 2 THEN ssp.period_spent ELSE 0 END) AS q2_spent,
  MAX(CASE WHEN ssp.quarter = 3 THEN ssp.period_spent ELSE 0 END) AS q3_spent,
  MAX(CASE WHEN ssp.quarter = 4 THEN ssp.period_spent ELSE 0 END) AS q4_spent,
  -- Calculate quarter-over-quarter growth
  ROUND(
    (MAX(CASE WHEN ssp.quarter = 4 THEN ssp.period_spent ELSE 0 END) - 
     MAX(CASE WHEN ssp.quarter = 3 THEN ssp.period_spent ELSE 0 END)) / 
    NULLIF(MAX(CASE WHEN ssp.quarter = 3 THEN ssp.period_spent ELSE 0 END), 0) * 100, 
    2
  ) AS q4_q3_growth_pct,
  -- Weekend vs. weekday spending
  SUM(CASE WHEN ssp.day_of_week IN (1, 7) THEN ssp.period_spent ELSE 0 END) AS weekend_spent,
  SUM(CASE WHEN ssp.day_of_week NOT IN (1, 7) THEN ssp.period_spent ELSE 0 END) AS weekday_spent,
  -- Average order values
  AVG(ssp.avg_order_value) AS overall_aov,
  -- Recency calculation
  DATEDIFF('2024-12-31', cps.last_purchase_date) AS days_since_last_purchase,
  -- Add RFM (Recency, Frequency, Monetary) scoring
  NTILE(5) OVER (ORDER BY DATEDIFF('2024-12-31', cps.last_purchase_date)) AS recency_score,
  NTILE(5) OVER (ORDER BY cps.order_count) AS frequency_score,
  NTILE(5) OVER (ORDER BY cps.total_spent) AS monetary_score
FROM customer_purchase_summary cps
LEFT JOIN product_category_preferences pcp ON cps.customer_id = pcp.customer_id
LEFT JOIN seasonal_spending_patterns ssp ON cps.customer_id = ssp.customer_id
GROUP BY
  cps.customer_id,
  cps.customer_name,
  cps.age_group,
  cps.gender,
  cps.region_name,
  cps.country,
  cps.total_spent,
  cps.order_count,
  cps.first_purchase_date,
  cps.last_purchase_date,
  cps.customer_tenure_days
HAVING cps.total_spent > 500
ORDER BY cps.total_spent DESC
LIMIT 1000;

apiCost: 0.0123