=============================================
Author:   AAVA
Created on:   
Description:   Loads the FACT_EXECUTIVE_SUMMARY table from staging metrics, performing data quality validation, business rule checks, and referential integrity enforcement.
=============================================

**1. Workflow Overview**

This stored procedure, `dbo.LOAD_FACT_EXECUTIVE_SUMMARY`, is designed to populate the `FACT_EXECUTIVE_SUMMARY` fact table in Synapse Analytics. It extracts data from the `STG_HOLDING_METRICS` staging table, performs data quality and business rule validations, joins with several dimension tables to enforce referential integrity, and loads the cleansed and enriched data into the target fact table. The procedure also includes basic audit logging and cleanup of temporary staging resources.

**Key Business Objective:**  
Data integration, cleansing, enrichment, and transformation to support executive-level reporting and analytics.

---

**2. Complexity Metrics**

| Metric                                   | Description                                                                 | Value / Details                                   |
|-------------------------------------------|-----------------------------------------------------------------------------|---------------------------------------------------|
| Number of Input Tables                    | Count of distinct source tables used in the procedure.                      | 5 (`STG_HOLDING_METRICS`, `DIM_DATE`, `DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`) |
| Number of Output Tables                   | Count of target or intermediate tables modified or populated.                | 1 target (`FACT_EXECUTIVE_SUMMARY`), 1 temp (`#staging_metrics`) |
| Variable Declarations                     | Number of declared variables and their usage complexity.                     | 2 (`@v_row_count`, `@error_message`), simple usage |
| Conditional Logic                        | Number of IF, CASE, or nested conditional blocks.                           | 3 (`IF OBJECT_ID...DROP TABLE`, `CASE` in SELECT, repeated for cleanup) |
| Loop Constructs                          | Number of WHILE or FOR loops, if present.                                   | 0                                                 |
| Join Conditions                          | Count and types of joins (INNER, LEFT, RIGHT, FULL).                        | 4 INNER JOINs                                     |
| Aggregations                             | Number of aggregation operations (SUM, COUNT, AVG, etc.).                   | 0 (no aggregations in this procedure)             |
| Subqueries / CTEs                        | Number of subqueries or Common Table Expressions used.                      | 0                                                 |
| Procedural Calls                         | Number of stored procedure or function invocations.                         | 0                                                 |
| DML Operations                           | Frequency of INSERT, UPDATE, DELETE, MERGE operations.                      | 1 INSERT, 2 DROP TABLEs                           |
| Temporary Tables / Table Variables        | Number of temp tables or table variables created and used.                  | 1 temp table (`#staging_metrics`)                 |
| Transaction Handling                     | Count of BEGIN TRAN, COMMIT, ROLLBACK statements.                           | 0                                                 |
| Error Handling Blocks                    | Presence and count of TRY...CATCH logic.                                    | 0                                                 |
| Complexity Score (0–100)                 | Based on nested logic, control flow, DML count, and procedural depth.       | 25 (Low–Moderate: simple control flow, no loops, limited variables, straightforward joins) |

**High-Complexity Areas:**
- Use of temporary table for staging.
- Multiple joins for referential integrity.
- Conditional logic for data quality (CASE in SELECT).
- No dynamic SQL, no procedural loops, minimal nested logic.

---

**3. Syntax Differences**

- **Variable Declarations:**  
  `DECLARE` statements and procedural variables (e.g., `@v_row_count`, `@error_message`) do not have direct equivalents in Fabric code and must be replaced with declarative logic or removed.
- **Temporary Tables:**  
  Creation and management of temp tables (`#staging_metrics`) should be replaced with CTEs or view-based logic in Fabric.
- **Control Flow:**  
  Procedural constructs like `IF OBJECT_ID...DROP TABLE`, `PRINT`, and variable assignment (`SET`) are not supported in Fabric code. Replace with comments or logging mechanisms supported by Fabric pipelines.
- **Audit Logging:**  
  `PRINT` statements and variable-based row count tracking should be replaced with Fabric-supported logging or monitoring features.
- **Data Types:**  
  Ensure that any implicit data types (e.g., `INT`, `NVARCHAR`) are compatible with Fabric; adjust as needed (e.g., `DATETIME` to `TIMESTAMP`).
- **Transaction Handling:**  
  No explicit transaction or error handling logic present, but if required, Fabric uses different mechanisms.

---

**4. Manual Adjustments**

- **Temp Table Logic:**  
  Replace temp table logic with CTEs or inline subqueries.
- **Variable and Print Statements:**  
  Remove or replace all variable declarations, assignments, and `PRINT` statements with Fabric-compatible logging.
- **Error Handling:**  
  No TRY...CATCH blocks present, but if error handling is required, implement using Fabric’s error handling features.
- **Audit Logging:**  
  Manual implementation needed for row count/audit logging in Fabric.
- **Business Rule Validation:**  
  The `CASE` logic for `income_amount` should be validated post-conversion to ensure parity.
- **External Dependencies:**  
  None detected (no external procedure/function calls).

---

**5. Optimization Techniques**

- **Use CTEs:**  
  Replace temp tables with sequential CTEs to streamline data flow and reduce intermediate storage.
- **Modularize Joins:**  
  If joins become complex, modularize using multiple CTEs for clarity and maintainability.
- **Predicate Pushdown:**  
  Apply filters as early as possible in CTEs to minimize data movement.
- **Reduce Redundancy:**  
  Combine selection and transformation logic into a single query where possible.
- **Refactor vs. Rebuild:**  
  This procedure is a good candidate for **Refactor**—retain core logic but restructure for declarative, set-based Fabric code.

---

**6. API Cost Consumption**

```
apiCost: 0.0523 USD
```