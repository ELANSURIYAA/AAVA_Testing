```
=============================================
Author:   AAVA
Created on:   
Description:   Loads the FACT_EXECUTIVE_SUMMARY fact table from staging metrics, performing data quality validation, business rule checks, and ensuring referential integrity via joins to dimension tables.
=============================================

**1. Workflow Overview**

This stored procedure, `dbo.LOAD_FACT_EXECUTIVE_SUMMARY`, is designed to load the `FACT_EXECUTIVE_SUMMARY` fact table from the `STG_HOLDING_METRICS` staging table. It performs data preparation, data quality validation, business rule enforcement, and ensures referential integrity by joining with several dimension tables. The procedure supports the business objective of data integration, cleansing, enrichment, and transformation for downstream analytics and reporting.

**2. Complexity Metrics**

| Metric                                   | Description                                                                 | Value / Notes                                                  |
|-------------------------------------------|-----------------------------------------------------------------------------|---------------------------------------------------------------|
| Number of Input Tables                    | Count of distinct source tables used in the procedure.                      | 5 (`STG_HOLDING_METRICS`, `DIM_DATE`, `DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`) |
| Number of Output Tables                   | Count of target or intermediate tables modified or populated.                | 1 (`FACT_EXECUTIVE_SUMMARY`)                                  |
| Variable Declarations                     | Number of declared variables and their usage complexity.                     | 2 (`@v_row_count`, `@error_message`) – simple usage           |
| Conditional Logic                         | Number of IF, CASE, or nested conditional blocks.                           | 3 (2 IFs for temp table existence, 1 CASE for business rule)  |
| Loop Constructs                           | Number of WHILE or FOR loops, if present.                                   | 0                                                             |
| Join Conditions                           | Count and types of joins (INNER, LEFT, RIGHT, FULL).                        | 4 INNER JOINs                                                 |
| Aggregations                              | Number of aggregation operations (SUM, COUNT, AVG, etc.).                   | 0 (no explicit aggregations)                                  |
| Subqueries / CTEs                         | Number of subqueries or Common Table Expressions used.                       | 0 (none used)                                                 |
| Procedural Calls                          | Number of stored procedure or function invocations.                          | 0                                                             |
| DML Operations                            | Frequency of INSERT, UPDATE, DELETE, MERGE operations.                       | 1 (INSERT INTO ... SELECT)                                    |
| Temporary Tables / Table Variables         | Number of temp tables or table variables created and used.                   | 1 temp table (`#staging_metrics`)                             |
| Transaction Handling                      | Count of BEGIN TRAN, COMMIT, ROLLBACK statements.                            | 0                                                             |
| Error Handling Blocks                     | Presence and count of TRY...CATCH logic.                                    | 0                                                             |
| Complexity Score (0–100)                  | Based on nested logic, control flow, DML count, and procedural depth.        | 25 (Low complexity: simple control flow, no loops, few variables) |

**High-complexity areas:**
- No deeply nested conditional logic.
- Multiple joins (4 INNER JOINs) but straightforward.
- No dynamic SQL execution.
- Minimal dependency on procedural control flow.

**3. Syntax Differences**

- **Variable Declarations:** T-SQL `DECLARE` statements (`@v_row_count`, `@error_message`) are not directly supported in Fabric code and must be replaced with alternative logic or removed if not essential.
- **Temporary Tables:** Usage of temp tables (`#staging_metrics`) should be replaced with CTEs or materialized views in Fabric code.
- **Control Flow:** T-SQL procedural constructs like `IF OBJECT_ID(...) IS NOT NULL DROP TABLE ...`, `PRINT`, and variable assignments are not directly supported. Equivalent logic should be implemented using declarative SQL or Fabric-native constructs.
- **CASE Statements:** Supported, but ensure compatibility with Fabric SQL dialect.
- **Data Types:** Ensure that data types such as `NVARCHAR`, `INT`, etc., are compatible or mapped correctly (e.g., `DATETIME` → `TIMESTAMP` if present).
- **No explicit transaction or error handling:** No TRY...CATCH or transaction blocks to convert.

**4. Manual Adjustments**

- **Audit Logging:** `PRINT` statements and variable-based row counts (`@v_row_count = @@ROWCOUNT`) for audit/logging will need to be replaced with Fabric-compatible logging or monitoring mechanisms.
- **Temp Table Management:** Manual conversion of temp table logic to CTEs or managed tables/views.
- **Business Rule Validation:** The CASE logic for `income_amount` should be validated post-conversion to ensure business rules are preserved.
- **External Dependencies:** None present in this code, but ensure any referenced dimension or staging tables exist and are populated as expected in Fabric.
- **Cleanup Steps:** Explicit temp table drops should be replaced with logic that avoids persistent temp objects.

**5. Optimization Techniques**

- **Use CTEs:** Replace temp tables with sequential CTEs for staging and transformation logic.
- **Modularize Joins:** If joins become complex, modularize them into separate CTEs for clarity and maintainability.
- **Predicate Pushdown:** Where possible, filter staging data early to reduce join cardinality.
- **Reduce Materializations:** Avoid unnecessary intermediate tables; chain transformations declaratively.
- **Refactor vs. Rebuild:** This procedure is simple enough to refactor directly into Fabric code using best practices, rather than requiring a full rebuild.

**6. API Cost Consumption**

```
apiCost: 0.0523 USD