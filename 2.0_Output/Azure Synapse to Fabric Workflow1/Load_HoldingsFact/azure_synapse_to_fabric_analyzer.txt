=============================================
Author:   AAVA
Created on:   
Description:   Loads the FACT_EXECUTIVE_SUMMARY table from staging metrics, performing data quality validation, business rule checks, and ensuring referential integrity via joins to dimension tables.
=============================================

**1. Workflow Overview**

This stored procedure, `dbo.LOAD_FACT_EXECUTIVE_SUMMARY`, is designed to load the `FACT_EXECUTIVE_SUMMARY` fact table from the staging table `STG_HOLDING_METRICS`. It performs data quality validation, applies business rules (such as handling negative or null income amounts), and ensures referential integrity by joining with dimension tables (`DIM_DATE`, `DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`). The workflow includes staging data preparation, fact table population, audit logging, and cleanup of temporary resources.

Key business objective: Data integration and transformation for executive summary reporting, ensuring accurate and validated holdings metrics are loaded into the data warehouse.

---

**2. Complexity Metrics**

| Metric                                   | Description                                                                 | Value / Notes                                   |
|-------------------------------------------|-----------------------------------------------------------------------------|-------------------------------------------------|
| Number of Input Tables                    | Count of distinct source tables used in the procedure.                      | 1 (`STG_HOLDING_METRICS`)                       |
| Number of Output Tables                   | Count of target or intermediate tables modified or populated.                | 1 (`FACT_EXECUTIVE_SUMMARY`) + 1 temp table     |
| Variable Declarations                     | Number of declared variables and their usage complexity.                     | 2 (`@v_row_count`, `@error_message`)            |
| Conditional Logic                         | Number of IF, CASE, or nested conditional blocks.                           | 2 (IF for temp table existence, CASE for income)|
| Loop Constructs                           | Number of WHILE or FOR loops, if present.                                   | 0                                               |
| Join Conditions                           | Count and types of joins (INNER, LEFT, RIGHT, FULL).                        | 4 INNER JOINs                                   |
| Aggregations                              | Number of aggregation operations (SUM, COUNT, AVG, etc.).                   | 0 (none in main SELECT)                         |
| Subqueries / CTEs                         | Number of subqueries or Common Table Expressions used.                      | 0                                               |
| Procedural Calls                          | Number of stored procedure or function invocations.                         | 0                                               |
| DML Operations                            | Frequency of INSERT, UPDATE, DELETE, MERGE operations.                      | 1 INSERT, 2 DROP TABLEs                         |
| Temporary Tables / Table Variables        | Number of temp tables or table variables created and used.                   | 1 temp table (`#staging_metrics`)               |
| Transaction Handling                      | Count of BEGIN TRAN, COMMIT, ROLLBACK statements.                           | 0                                               |
| Error Handling Blocks                     | Presence and count of TRY...CATCH logic.                                    | 0                                               |
| Complexity Score (0â€“100)                  | Based on nested logic, control flow, DML count, and procedural depth.        | 25                                              |

**High-complexity areas:**
- Use of temporary tables for staging.
- Multiple joins for referential integrity.
- Conditional logic for data quality (CASE for income).
- Control flow for resource cleanup.

---

**3. Syntax Differences**

- **Variable Declarations:** Synapse uses `DECLARE` for variables (e.g., `@v_row_count`). Fabric code typically avoids procedural variables, favoring CTEs or direct SQL expressions.
- **Temporary Tables:** `#staging_metrics` is a temp table; in Fabric, prefer using CTEs or views for staging logic.
- **Control Flow:** IF statements for resource cleanup and CASE for business rules. Fabric code should replace IF logic with SQL constructs or modular queries.
- **PRINT Statements:** Used for audit logging; Fabric code does not support procedural PRINT, so logging must be handled externally.
- **Procedural Blocks:** BEGIN...END procedural blocks are not directly supported; Fabric code should be declarative.
- **Transaction Handling:** No explicit transaction logic here, but if present, would need refactoring.
- **Data Types:** No explicit data type conversions in this code, but ensure compatibility (e.g., DATETIME vs. TIMESTAMP) when migrating.

---

**4. Manual Adjustments**

- **Audit Logging:** PRINT statements for logging must be replaced with external monitoring or Fabric-compatible logging mechanisms.
- **Variable Usage:** Row count tracking (`@v_row_count = @@ROWCOUNT`) needs to be implemented using SQL expressions or external monitoring.
- **Temp Table Cleanup:** Resource management (DROP TABLE) should be replaced with ephemeral views or CTEs.
- **Conditional Logic:** CASE statements for business rules (e.g., handling income_amount) should be validated post-conversion to ensure parity.
- **External Dependencies:** None detected, but ensure dimension tables exist and are populated.
- **Business Rule Validation:** Manual review required to confirm logic matches business requirements after conversion.

---

**5. Optimization Techniques**

- **Modular Queries:** Replace temp tables with sequential CTEs to streamline data flow.
- **Join Optimization:** Ensure joins are predicate-pushed and leverage partitioning if possible for large tables.
- **Reduce Materializations:** Avoid unnecessary intermediate tables; use views or CTEs for staging.
- **Simplify Logic:** Refactor CASE and IF logic into declarative SQL expressions.
- **Audit Logging:** Integrate with Fabric monitoring tools for row counts and job status.
- **Refactor vs. Rebuild:** Refactor is feasible for this workflow, as logic is straightforward and can be translated into Fabric code with modular queries and declarative constructs.

---

**6. API Cost Consumption**

```
apiCost: 0.0523 USD
```