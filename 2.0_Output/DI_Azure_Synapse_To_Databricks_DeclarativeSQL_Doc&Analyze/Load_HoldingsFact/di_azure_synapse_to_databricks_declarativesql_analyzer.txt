```
=============================================
Author:        AAVA
Created on:   
Description:   Loads FACT_EXECUTIVE_SUMMARY from STG_HOLDING_METRICS, performing data quality validation, business rule checks, and referential integrity enforcement via joins to dimension tables.
=============================================

# 1. Procedure Overview

This Azure Synapse stored procedure (`dbo.LOAD_FACT_EXECUTIVE_SUMMARY`) loads the `FACT_EXECUTIVE_SUMMARY` fact table from the staging table `STG_HOLDING_METRICS`. It performs data quality validation, applies business rules (such as handling null or negative income values), and ensures referential integrity by joining with dimension tables (`DIM_DATE`, `DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`). The procedure supports business objectives around regulatory reporting, executive dashboards, and advanced analytics by summarizing holding metrics for downstream consumption.

# 2. Complexity Metrics

| Metric                                 | Description                                                                                       | Value/Details                                   |
|-----------------------------------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------|
| Number of Input Tables                  | Count of distinct source tables used in the procedure.                                            | 5 (STG_HOLDING_METRICS, DIM_DATE, DIM_INSTITUTION, DIM_CORPORATION, DIM_PRODUCT) |
| Number of Output Tables                 | Count of target or intermediate tables modified or populated.                                      | 1 (FACT_EXECUTIVE_SUMMARY) + 1 temp table (#staging_metrics)                      |
| Variable Declarations                   | Number of declared variables and their usage complexity.                                           | 2 (`@v_row_count`, `@error_message`) - simple usage                                |
| Conditional Logic                       | Number of IF, CASE, or nested conditional blocks.                                                  | 3 (2 IFs for temp table existence, 1 CASE for income_amount)                       |
| Loop Constructs                         | Number of WHILE or FOR loops, if present.                                                          | 0                                              |
| Join Conditions                         | Count and types of joins (INNER, LEFT, RIGHT, FULL).                                               | 4 INNER JOINs                                  |
| Aggregations                            | Number of aggregation operations (SUM, COUNT, AVG, etc.).                                          | 0 (no explicit aggregation, only transformation)                                    |
| Subqueries / CTEs                       | Number of subqueries or Common Table Expressions used.                                             | 0                                              |
| Procedural Calls                        | Number of stored procedure or function invocations.                                                | 0                                              |
| DML Operations                          | Frequency of INSERT, UPDATE, DELETE, MERGE operations.                                             | 1 INSERT, 1 SELECT INTO, 2 DROP TABLE IF EXISTS                                    |
| Temporary Tables / Table Variables      | Number of temp tables or table variables created and used.                                         | 1 temp table (#staging_metrics)                |
| Transaction Handling                    | Count of BEGIN TRAN, COMMIT, ROLLBACK statements.                                                  | 0                                              |
| Error Handling Blocks                   | Presence and count of TRY...CATCH logic.                                                           | 0                                              |
| Complexity Score (0–100)                | Based on nested logic, control flow, DML count, and procedural depth.                              | 30                                             |

**High-complexity areas:**
- Use of temp tables for staging data.
- Multiple INNER JOINs to dimension tables for referential integrity.
- Conditional logic for data quality (CASE for income_amount).
- No dynamic SQL, procedural loops, or nested control flow.

# 3. Syntax Differences

- **Variable Declarations:** 
  - T-SQL uses `DECLARE @var ...`; Databricks declarative SQL does not support procedural variables. Logic relying on variables (e.g., row counts, error messages) must be handled via queries or external orchestration.
- **Temp Tables:** 
  - T-SQL temp tables (`#staging_metrics`) are not directly supported; use CTEs or views in Databricks SQL.
- **Control Flow:** 
  - IF statements for object existence checks and procedural PRINT statements are not supported in declarative SQL. These must be omitted or replaced by orchestration logic.
- **DML Operations:** 
  - `SELECT INTO` for temp table creation is not supported; use CTEs or explicit CREATE TABLE AS SELECT if necessary.
- **Transaction/Session Handling:** 
  - No explicit transaction handling (`BEGIN TRAN`, `COMMIT`, `ROLLBACK`) in this procedure, but if present, would need to be omitted or managed externally.
- **Error Handling:** 
  - No TRY...CATCH blocks in this code, but if present, would need to be handled via orchestration or external logic.
- **PRINT Statements:** 
  - Not supported in Databricks SQL; use logging or orchestration for status messages.
- **System Variables:** 
  - `@@ROWCOUNT` is not available; row counts must be obtained via queries.
- **Data Types:** 
  - No explicit data type conversions required in this code, but ensure compatibility (e.g., DATETIME → TIMESTAMP) if present.

# 4. Manual Adjustments

- **Temp Table Logic:** 
  - Replace temp table usage with CTEs or views in Databricks SQL.
- **Variable and Audit Logging:** 
  - Manual implementation required for row count logging and error messages; typically handled in orchestration (e.g., notebooks or workflows).
- **Control Flow and Existence Checks:** 
  - IF OBJECT_ID checks and DROP TABLE statements must be omitted or handled externally.
- **PRINT Statements:** 
  - Remove or replace with notebook markdown/logging as needed.
- **Business Rule Validation:** 
  - CASE logic for `income_amount` must be validated post-conversion to ensure parity.
- **External Dependencies:** 
  - Ensure all dimension tables exist and are accessible in Databricks environment.
- **No procedural constructs:** 
  - Any procedural logic (not present here, but common in other procedures) would require manual refactoring.

# 5. Optimization Techniques

- **Replace temp tables with CTEs:** 
  - Use sequential CTEs to stage and transform data instead of temp tables.
- **Modularize logic:** 
  - Break down complex SELECT/INSERT statements into modular CTEs for clarity and maintainability.
- **Efficient Joins:** 
  - Ensure join columns are indexed and leverage predicate pushdown where possible.
- **Minimize intermediate materializations:** 
  - Avoid unnecessary intermediate tables; chain transformations in a single query.
- **Simplify conditional logic:** 
  - Use CASE statements directly in SELECTs; avoid deeply nested logic.
- **Remove redundant operations:** 
  - Omit existence checks and cleanup steps unnecessary in declarative SQL.

# 6. API Cost Consumption

```
apiCost: 0.0040 USD