1. Summary

The original Hive SQL and the converted BigQuery SQL both implement a customer purchase pattern analysis, using three main CTEs to aggregate customer purchase summaries, product category preferences, and seasonal spending patterns. The final SELECT combines these aggregates, applies segmentation logic, calculates frequency and recency, and outputs a ranked, filtered customer list.

2. Conversion Accuracy

- **CTEs**: All three CTEs (`customer_purchase_summary`, `product_category_preferences`, `seasonal_spending_patterns`) are faithfully reproduced in the BigQuery version, with equivalent logic and structure.
- **Joins**: All join conditions and types (INNER, LEFT) are preserved.
- **Aggregations**: SUM, COUNT, MIN, MAX, AVG, and window functions (ROW_NUMBER, NTILE) are accurately mapped.
- **Conditional Logic**: The CASE statements for customer tiering and category selection are correctly translated.
- **Date Functions**: Hive's `DATEDIFF` is translated to BigQuery's `DATE_DIFF`; `QUARTER`, `MONTH`, `DAYOFWEEK` are mapped to BigQuery's `EXTRACT`.
- **Null Handling**: Use of `NULLIF` and `SAFE_DIVIDE` in BigQuery ensures robust handling of division by zero and nulls.
- **Window Functions**: ROW_NUMBER and NTILE are correctly rewritten for BigQuery syntax.
- **Filtering, Ordering, Limiting**: HAVING, ORDER BY, and LIMIT are preserved.

3. Discrepancies and Issues

- **Date Functions**: Hive's `DATEDIFF('2024-12-31', cps.last_purchase_date)` is correctly mapped to `DATE_DIFF(DATE '2024-12-31', cps.last_purchase_date, DAY)` in BigQuery.
- **CASE/IF**: Hive's `CASE WHEN ... THEN ... ELSE ... END` is mapped to BigQuery's `CASE` and also to `IF` for inline conditional selection.
- **Window Functions**: The use of `NTILE(5) OVER (ORDER BY ...)` is supported in both, but BigQuery's implementation is more robust for large datasets.
- **Partitioning/Bucketing**: The original Hive query does not use explicit partitioning or bucketing in the query itself, so no translation is needed.
- **Data Types**: All data types are compatible or safely cast in BigQuery.
- **No Use of Hive-specific UDFs or LATERAL VIEW/EXPLODE**: The query does not use features that require manual intervention or complex rewrites.

No functional gaps or missing logic were found in the conversion.

4. Optimization Suggestions

- **Partitioning/Clustering**: For large datasets, ensure the underlying BigQuery tables (`orders`, `order_items`, etc.) are partitioned (e.g., by `order_date`) and clustered (e.g., by `customer_id`, `region_id`) for optimal performance and cost.
- **Materialized Views**: If this analysis is run frequently, consider materializing the CTEs or using BigQuery materialized views for `customer_purchase_summary`.
- **Column Pruning**: Only select columns needed for downstream use to reduce scan costs.
- **Safe Division**: Use `SAFE_DIVIDE` everywhere division occurs to avoid errors (already present in the BigQuery code).
- **Cost Control**: Use BigQuery's query dry-run feature to estimate costs before running on large datasets.
- **Denormalization**: If query latency is a concern, denormalize reference data (e.g., region, product category) into the main fact tables.

5. Overall Assessment

- **Correctness**: The BigQuery SQL is a faithful and accurate translation of the Hive logic, with all business rules and data flows preserved.
- **Completeness**: All features, calculations, and aggregations are present and equivalent.
- **Efficiency**: The query is well-optimized for BigQuery, using native functions, windowing, and safe null handling.
- **Maintainability**: The structure is clear, with logical CTEs and readable final SELECT.

6. Recommendations

- **Testing**: Use the provided test suite (TC01-TC17) and pytest script to validate correctness, performance, and edge cases.
- **Performance**: Monitor query execution time and slot usage; optimize table partitioning if needed.
- **Documentation**: Document the mapping of Hive features to BigQuery equivalents for future reference.
- **Automation**: Use the provided migration validation Python script to automate regression testing between Hive and BigQuery outputs.
- **Cost Monitoring**: Regularly review BigQuery query costs and optimize as needed.

7. API Cost

- API cost for this call: $0.005

---

**Full Content for Documentation and Codebase:**

---

### 1. Original Hive SQL

```sql
-- Complex Hive Query for Customer Purchase Pattern Analysis
-- This query analyzes purchasing behavior across regions, demographics, and time periods

WITH customer_purchase_summary AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.age_group,
    c.gender,
    c.region_id,
    r.region_name,
    r.country,
    SUM(o.order_amount) AS total_spent,
    COUNT(DISTINCT o.order_id) AS order_count,
    MIN(o.order_date) AS first_purchase_date,
    MAX(o.order_date) AS last_purchase_date,
    DATEDIFF(MAX(o.order_date), MIN(o.order_date)) AS customer_tenure_days
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN regions r ON c.region_id = r.region_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND o.order_status = 'COMPLETED'
  GROUP BY 
    c.customer_id, 
    c.customer_name,
    c.age_group,
    c.gender,
    c.region_id,
    r.region_name,
    r.country
),

product_category_preferences AS (
  SELECT 
    o.customer_id,
    p.category_id,
    pc.category_name,
    COUNT(DISTINCT o.order_id) AS category_purchase_count,
    SUM(oi.quantity) AS items_purchased,
    SUM(oi.quantity * oi.unit_price) AS category_amount_spent,
    ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY SUM(oi.quantity * oi.unit_price) DESC) AS category_rank
  FROM orders o
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND o.order_status = 'COMPLETED'
  GROUP BY 
    o.customer_id,
    p.category_id,
    pc.category_name
),

seasonal_spending_patterns AS (
  SELECT
    c.customer_id,
    QUARTER(o.order_date) AS quarter,
    MONTH(o.order_date) AS month,
    DAYOFWEEK(o.order_date) AS day_of_week,
    SUM(o.order_amount) AS period_spent,
    COUNT(DISTINCT o.order_id) AS period_order_count,
    AVG(o.order_amount) AS avg_order_value
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND o.order_status = 'COMPLETED'
  GROUP BY
    c.customer_id,
    QUARTER(o.order_date),
    MONTH(o.order_date),
    DAYOFWEEK(o.order_date)
)

SELECT 
  cps.customer_id,
  cps.customer_name,
  cps.age_group,
  cps.gender,
  cps.region_name,
  cps.country,
  cps.total_spent,
  cps.order_count,
  cps.customer_tenure_days,
  -- Calculate customer lifetime value and segmentation
  CASE 
    WHEN cps.total_spent > 10000 THEN 'Platinum'
    WHEN cps.total_spent > 5000 THEN 'Gold'
    WHEN cps.total_spent > 1000 THEN 'Silver'
    ELSE 'Bronze'
  END AS customer_tier,
  -- Calculate purchase frequency metrics
  ROUND(cps.order_count / NULLIF(cps.customer_tenure_days / 30, 0), 2) AS monthly_purchase_frequency,
  -- Get preferred product categories
  MAX(CASE WHEN pcp.category_rank = 1 THEN pcp.category_name ELSE NULL END) AS top_category,
  MAX(CASE WHEN pcp.category_rank = 1 THEN pcp.category_amount_spent ELSE NULL END) AS top_category_spent,
  MAX(CASE WHEN pcp.category_rank = 2 THEN pcp.category_name ELSE NULL END) AS second_category,
  MAX(CASE WHEN pcp.category_rank = 2 THEN pcp.category_amount_spent ELSE NULL END) AS second_category_spent,
  -- Seasonal spending analysis
  MAX(CASE WHEN ssp.quarter = 1 THEN ssp.period_spent ELSE 0 END) AS q1_spent,
  MAX(CASE WHEN ssp.quarter = 2 THEN ssp.period_spent ELSE 0 END) AS q2_spent,
  MAX(CASE WHEN ssp.quarter = 3 THEN ssp.period_spent ELSE 0 END) AS q3_spent,
  MAX(CASE WHEN ssp.quarter = 4 THEN ssp.period_spent ELSE 0 END) AS q4_spent,
  -- Calculate quarter-over-quarter growth
  ROUND(
    (MAX(CASE WHEN ssp.quarter = 4 THEN ssp.period_spent ELSE 0 END) - 
     MAX(CASE WHEN ssp.quarter = 3 THEN ssp.period_spent ELSE 0 END)) / 
    NULLIF(MAX(CASE WHEN ssp.quarter = 3 THEN ssp.period_spent ELSE 0 END), 0) * 100, 
    2
  ) AS q4_q3_growth_pct,
  -- Weekend vs. weekday spending
  SUM(CASE WHEN ssp.day_of_week IN (1, 7) THEN ssp.period_spent ELSE 0 END) AS weekend_spent,
  SUM(CASE WHEN ssp.day_of_week NOT IN (1, 7) THEN ssp.period_spent ELSE 0 END) AS weekday_spent,
  -- Average order values
  AVG(ssp.avg_order_value) AS overall_aov,
  -- Recency calculation
  DATEDIFF('2024-12-31', cps.last_purchase_date) AS days_since_last_purchase,
  -- Add RFM (Recency, Frequency, Monetary) scoring
  NTILE(5) OVER (ORDER BY DATEDIFF('2024-12-31', cps.last_purchase_date)) AS recency_score,
  NTILE(5) OVER (ORDER BY cps.order_count) AS frequency_score,
  NTILE(5) OVER (ORDER BY cps.total_spent) AS monetary_score
FROM customer_purchase_summary cps
LEFT JOIN product_category_preferences pcp ON cps.customer_id = pcp.customer_id
LEFT JOIN seasonal_spending_patterns ssp ON cps.customer_id = ssp.customer_id
GROUP BY
  cps.customer_id,
  cps.customer_name,
  cps.age_group,
  cps.gender,
  cps.region_name,
  cps.country,
  cps.total_spent,
  cps.order_count,
  cps.first_purchase_date,
  cps.last_purchase_date,
  cps.customer_tenure_days
HAVING cps.total_spent > 500
ORDER BY cps.total_spent DESC
LIMIT 1000;
```

---

### 2. Converted BigQuery SQL

```sql
-- BigQuery Conversion: Customer Purchase Pattern Analysis

WITH customer_purchase_summary AS (
  SELECT 
    c.customer_id,
    c.customer_name,
    c.age_group,
    c.gender,
    c.region_id,
    r.region_name,
    r.country,
    SUM(o.order_amount) AS total_spent,
    COUNT(DISTINCT o.order_id) AS order_count,
    MIN(o.order_date) AS first_purchase_date,
    MAX(o.order_date) AS last_purchase_date,
    DATE_DIFF(MAX(o.order_date), MIN(o.order_date), DAY) AS customer_tenure_days
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN regions r ON c.region_id = r.region_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
    AND o.order_status = 'COMPLETED'
  GROUP BY 
    c.customer_id, 
    c.customer_name,
    c.age_group,
    c.gender,
    c.region_id,
    r.region_name,
    r.country
),

product_category_preferences AS (
  SELECT 
    o.customer_id,
    p.category_id,
    pc.category_name,
    COUNT(DISTINCT o.order_id) AS category_purchase_count,
    SUM(oi.quantity) AS items_purchased,
    SUM(oi.quantity * oi.unit_price) AS category_amount_spent,
    ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY SUM(oi.quantity * oi.unit_price) DESC) AS category_rank
  FROM orders o
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
    AND o.order_status = 'COMPLETED'
  GROUP BY 
    o.customer_id,
    p.category_id,
    pc.category_name
),

seasonal_spending_patterns AS (
  SELECT
    c.customer_id,
    EXTRACT(QUARTER FROM o.order_date) AS quarter,
    EXTRACT(MONTH FROM o.order_date) AS month,
    EXTRACT(DAYOFWEEK FROM o.order_date) AS day_of_week,
    SUM(o.order_amount) AS period_spent,
    COUNT(DISTINCT o.order_id) AS period_order_count,
    AVG(o.order_amount) AS avg_order_value
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  WHERE o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
    AND o.order_status = 'COMPLETED'
  GROUP BY
    c.customer_id,
    EXTRACT(QUARTER FROM o.order_date),
    EXTRACT(MONTH FROM o.order_date),
    EXTRACT(DAYOFWEEK FROM o.order_date)
)

SELECT 
  cps.customer_id,
  cps.customer_name,
  cps.age_group,
  cps.gender,
  cps.region_name,
  cps.country,
  cps.total_spent,
  cps.order_count,
  cps.customer_tenure_days,
  -- Calculate customer lifetime value and segmentation
  CASE 
    WHEN cps.total_spent > 10000 THEN 'Platinum'
    WHEN cps.total_spent > 5000 THEN 'Gold'
    WHEN cps.total_spent > 1000 THEN 'Silver'
    ELSE 'Bronze'
  END AS customer_tier,
  -- Calculate purchase frequency metrics
  ROUND(cps.order_count / NULLIF(cps.customer_tenure_days / 30.0, 0), 2) AS monthly_purchase_frequency,
  -- Get preferred product categories
  MAX(IF(pcp.category_rank = 1, pcp.category_name, NULL)) AS top_category,
  MAX(IF(pcp.category_rank = 1, pcp.category_amount_spent, NULL)) AS top_category_spent,
  MAX(IF(pcp.category_rank = 2, pcp.category_name, NULL)) AS second_category,
  MAX(IF(pcp.category_rank = 2, pcp.category_amount_spent, NULL)) AS second_category_spent,
  -- Seasonal spending analysis
  MAX(IF(ssp.quarter = 1, ssp.period_spent, 0)) AS q1_spent,
  MAX(IF(ssp.quarter = 2, ssp.period_spent, 0)) AS q2_spent,
  MAX(IF(ssp.quarter = 3, ssp.period_spent, 0)) AS q3_spent,
  MAX(IF(ssp.quarter = 4, ssp.period_spent, 0)) AS q4_spent,
  -- Calculate quarter-over-quarter growth
  ROUND(
    SAFE_DIVIDE(
      (MAX(IF(ssp.quarter = 4, ssp.period_spent, 0)) - MAX(IF(ssp.quarter = 3, ssp.period_spent, 0))),
      NULLIF(MAX(IF(ssp.quarter = 3, ssp.period_spent, 0)), 0)
    ) * 100, 2
  ) AS q4_q3_growth_pct,
  -- Weekend vs. weekday spending (1=Sunday, 7=Saturday in BigQuery)
  SUM(IF(ssp.day_of_week IN (1, 7), ssp.period_spent, 0)) AS weekend_spent,
  SUM(IF(ssp.day_of_week NOT IN (1, 7), ssp.period_spent, 0)) AS weekday_spent,
  -- Average order values
  AVG(ssp.avg_order_value) AS overall_aov,
  -- Recency calculation
  DATE_DIFF(DATE '2024-12-31', cps.last_purchase_date, DAY) AS days_since_last_purchase,
  -- Add RFM (Recency, Frequency, Monetary) scoring
  NTILE(5) OVER (ORDER BY DATE_DIFF(DATE '2024-12-31', cps.last_purchase_date, DAY)) AS recency_score,
  NTILE(5) OVER (ORDER BY cps.order_count) AS frequency_score,
  NTILE(5) OVER (ORDER BY cps.total_spent) AS monetary_score
FROM customer_purchase_summary cps
LEFT JOIN product_category_preferences pcp ON cps.customer_id = pcp.customer_id
LEFT JOIN seasonal_spending_patterns ssp ON cps.customer_id = ssp.customer_id
GROUP BY
  cps.customer_id,
  cps.customer_name,
  cps.age_group,
  cps.gender,
  cps.region_name,
  cps.country,
  cps.total_spent,
  cps.order_count,
  cps.first_purchase_date,
  cps.last_purchase_date,
  cps.customer_tenure_days
HAVING cps.total_spent > 500
ORDER BY cps.total_spent DESC
LIMIT 1000
;
```

---

### 3. Comprehensive Test Case List (TC01-TC17) and Pytest Script

(See previous output for full table and script.)

---

### 4. Automated Hive to BigQuery Migration Validation Python Script

(See previous output for full script.)

---

### 5. API Cost

API cost for this call: $0.005

---