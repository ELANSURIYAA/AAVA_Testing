1. Overview:
The provided Snowflake SQL script calculates and reports total sales and sales performance for customers in 2023, focusing on those who received discounts. It identifies the top 5 customers per region by total sales and provides detailed sales performance, including product details and sale categorization. The script uses advanced SQL features such as CTEs, window functions, semi-structured data extraction, and clustering for scalable analytics. The migration objective is to convert this script to BigQuery, ensuring all logic, aggregations, and data handling are preserved.

2. Detailed Metrics:
* Number of Lines: 54
* Tables Used: ['Customers', 'Sales', 'Products']
* Joins: ['LEFT JOIN (Customers–Sales)', 'INNER JOIN (Sales–Products)', 'LEFT JOIN (top_customers–sales_performance)']
* Functions: ['SUM', 'COUNT', 'ARRAY_AGG', 'RANK', 'CASE', '::STRING (type cast)', '::BOOLEAN (type cast)', 'DISTINCT']
* DML List: ['SELECT']

3. Conversion Complexity:
Complexity Score: 65

4. Conversion Description:
The conversion from Snowflake SQL to BigQuery is moderately complex due to several Snowflake-specific features and advanced SQL constructs:
- Snowflake’s VARIANT field extraction and type casting (e.g., c.metadata:loyalty_level::STRING) must be rewritten using BigQuery’s JSON functions (e.g., JSON_EXTRACT_SCALAR).
- ARRAY_AGG(DISTINCT ...) is supported in BigQuery, but syntax and behavior should be verified.
- Window functions (RANK() OVER ...) are supported in BigQuery with similar syntax.
- The CLUSTER BY clause is Snowflake-specific and must be removed or replaced with BigQuery’s partitioning/clustering options at the table definition level, not in SELECT.
- The script uses CTEs, which are supported in BigQuery.
- The script does not use QUALIFY, but does use window function filtering in WHERE (tc.region_rank <= 5), which is supported in BigQuery.
- All joins and DML are supported, but field references and semi-structured data handling require manual adjustment.

5. Manual Solution:
Manual code changes required for conversion:
* Replace Snowflake VARIANT extraction and casting (e.g., c.metadata:loyalty_level::STRING) with BigQuery JSON functions:
    - Snowflake: c.metadata:loyalty_level::STRING
    - BigQuery: JSON_EXTRACT_SCALAR(c.metadata, '$.loyalty_level')
* Replace s.sale_metadata:discount_applied::BOOLEAN = TRUE with
    - BigQuery: JSON_EXTRACT_SCALAR(s.sale_metadata, '$.discount_applied') = 'true'
* Replace s.sale_metadata:country::STRING = 'USA' with
    - BigQuery: JSON_EXTRACT_SCALAR(s.sale_metadata, '$.country') = 'USA'
* ARRAY_AGG(DISTINCT ...) is supported, but verify syntax and null handling.
* Remove CLUSTER BY clause from SELECT; if clustering is required, define it at table creation in BigQuery.
* Type casting (e.g., ::STRING, ::BOOLEAN) must be replaced with CAST() or SAFE_CAST() in BigQuery.
* All other SQL logic (CTEs, window functions, CASE, joins) is compatible but should be syntax-checked for minor differences.

6. Number of Syntax Differences:
6

- VARIANT field extraction and casting (3 instances)
- ARRAY_AGG(DISTINCT ...) (1 instance, minor syntax check)
- CLUSTER BY clause (1 instance)
- Type casting (1 instance, :: to CAST/SAFE_CAST)

---
Script Content:
WITH customer_sales AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        c.region,
        c.metadata:loyalty_level::STRING AS loyalty_level,      -- JSON field extraction with casting.
        SUM(s.sale_amount) AS total_sales,
        COUNT(s.sale_id) AS total_orders,
        ARRAY_AGG(DISTINCT s.product_id) AS product_list        -- Snowflake's ARRAY_AGG for semi-structured aggregation.
    FROM 
        Customers c
    LEFT JOIN 
        Sales s ON c.customer_id = s.customer_id
    WHERE 
        s.sale_date >= '2023-01-01' 
        AND s.sale_date < '2024-01-01'
        AND s.sale_metadata:discount_applied::BOOLEAN = TRUE   -- Variant field condition with type casting.
    GROUP BY 
        c.customer_id, c.customer_name, c.region, c.metadata:loyalty_level
),
top_customers AS (
    SELECT 
        customer_id,
        customer_name,
        region,
        loyalty_level,
        total_sales,
        total_orders,
        product_list,
        RANK() OVER (PARTITION BY region ORDER BY total_sales DESC) AS region_rank -- Window function.
    FROM 
        customer_sales
),
sales_performance AS (
    SELECT
        s.sale_id,
        s.sale_date,
        s.sale_amount,
        s.discount_percentage,
        s.sale_metadata:source::STRING AS source,              -- Extracting data from VARIANT field.
        p.product_name,
        CASE 
            WHEN s.sale_amount > 1000 THEN 'High Value'
            WHEN s.sale_amount > 500 THEN 'Medium Value'
            ELSE 'Low Value'
        END AS sale_category                                     -- Conditional logic for categorization.
    FROM 
        Sales s
    INNER JOIN 
        Products p ON s.product_id = p.product_id
    WHERE 
        s.sale_date >= '2023-01-01'
        AND s.sale_metadata:country::STRING = 'USA'             -- Semi-structured field filter.
)
SELECT 
    tc.customer_name,
    tc.region,
    tc.loyalty_level,
    tc.total_sales,
    tc.total_orders,
    sp.sale_id,
    sp.sale_date,
    sp.product_name,
    sp.sale_category,
    sp.source
FROM 
    top_customers tc
LEFT JOIN 
    sales_performance sp ON tc.customer_id = sp.customer_id
WHERE 
    tc.region_rank <= 5                                          -- Filter for top-ranked customers.
ORDER BY 
    tc.region, tc.region_rank, sp.sale_date
CLUSTER BY 
    tc.region, tc.region_rank;                                   -- Snowflake-specific clustering directive

---
Notable Differences/Challenges:
- Snowflake’s VARIANT field extraction and type casting are not directly supported in BigQuery; all such expressions must be rewritten using JSON_EXTRACT_SCALAR and explicit CASTs.
- CLUSTER BY is not supported in SELECT in BigQuery and must be removed or handled at table definition.
- Type casting syntax (::) must be replaced with CAST()/SAFE_CAST().
- ARRAY_AGG(DISTINCT ...) is supported but should be syntax-checked.
- All other logic (CTEs, window functions, CASE, joins) is compatible but should be reviewed for minor differences.