{
    "workflowId": 1118,
    "workflowName": "Snowflake_To_Bigquery_Doc_&_Analyze",
    "nodes": [
        {
            "agentName": "SNOWFLAKE DOCUMENTATION",
            "model": "gpt-4o",
            "tools": [],
            "task": {
                "description": "Please create detailed documentation for the provided Snowflake SQL code.\n\nThe documentation must contain the following sections:\n\n1.Overview of Program:\n\nExplain the purpose of the Snowflake SQL code in detail.\n\nDescribe how this implementation aligns with enterprise data warehousing and analytics.\n\nExplain the business problem being addressed and its benefits.\n\nProvide a high-level summary of Snowflake SQL components like Views, Stored Procedures, Staging Tables, and Data Pipelines.\n\n2.Code Structure and Design:\n\nExplain the structure of the Snowflake SQL code in detail.\n\nDescribe key components like DDL, DML, Joins, Indexing, and Stored Procedures.\n\nList the primary Snowflake SQL components such as Tables, Views, Stored Procedures, Joins, Aggregations, and CTEs.\n\nHighlight dependencies on Snowflake objects, performance tuning techniques, or third-party integrations.\n\n3.Data Flow and Processing Logic:\n\nExplain how data flows within the Snowflake SQL implementation.\n\nList the source and destination tables, fields, and data types.\n\nExplain the applied transformations, including filtering, joins, aggregations, and field calculations.\n\n4.Data Mapping:\n\nProvide data mapping details, including transformations applied to the data in the below format:\n\nTarget Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks\n\nMapping column will have the details whether it\u2019s 1 to 1 mapping or the transformation rule or the validation rule.\n\n5.Performance Optimization Strategies:\n\nExplain optimization techniques used in the Snowflake SQL implementation.\n\nDescribe strategies like Clustering Keys, Materialized Views, Caching, and Query Acceleration.\n\nExplain how performance is improved using techniques like Partition Pruning, Result Set Caching, and Warehouse Scaling.\n\nProvide real-world examples of optimization benefits.\n\n6.Technical Elements and Best Practices:\n\nExplain the technical elements involved in the Snowflake SQL code.\n\nList Snowflake system dependencies such as Database Connections, Table Structures, and Resource Management.\n\nMention best practices like Efficient Joins, Query Tuning, and Data Skew Handling.\n\nSpecify additional Snowflake tools like Snowpipe, Streams, Tasks, and Time Travel.\n\nDescribe error handling, logging, and exception tracking methods.\n\n7.Complexity Analysis:\n\nAnalyze and document the complexity based on the following:\n\nProvide this in a table format with the following columns:\n\nCategory\n\nMeasurement\n\nNumber of Lines: Count of lines in the SQL script.\n\nTables Used:\n\nNumber of tables referenced in the SQL script.\n\nJoins:\n\nNumber of joins and the types of joins used (e.g., INNER JOIN, LEFT JOIN, CROSS JOIN).\n\nTemporary Tables:\n\nNumber of Temporary and Derived Tables.\n\nAggregate Functions:\n\nNumber of aggregate functions like Window Functions.\n\nDML Statements:\n\nNumber of DML statements by type like SELECT, INSERT, UPDATE, DELETE, MERGE, COPY.\n\nConditional Logic:\n\nNumber of conditional logic like CASE, IF-ELSE, WHILE, ERROR HANDLING.\n\nSQL Query Complexity:\n\nNumber of joins, subqueries, and stored procedures.\n\nPerformance Considerations:\n\nQuery execution time, warehouse usage, and resource consumption.\n\nData Volume Handling:\n\nNumber of records processed.\n\nDependency Complexity:\n\nExternal dependencies such as Views, Procedures, Tasks, or Pipelines.\n\nOverall Complexity Score:\n\nScore from 0 to 100.\n\n8.Assumptions and Dependencies:\n\nList system prerequisites such as database connections, table structures, and access roles.\n\nMention infrastructure dependencies, including Snowflake Clusters, GCP Storage, or BigQuery.\n\nNote assumptions about data consistency, schema evolution, and workload management.\n\n9.Key Outputs:\n\nDescribe final outputs such as Aggregated Reports, Tables, Views, or Data Exports.\n\nExplain how outputs align with business goals and reporting needs.\n\nSpecify the storage format (e.g., Staging Tables, Production Tables, External Tables, or Parquet Files).\n\n10.Error Handling and Logging:\n\nExplain methods used for error identification and management, such as:\n\nTry-Catch mechanisms in Stored Procedures.\n\nSnowflake Error Logging with Query History and Streams.\n\nRetry mechanisms in Snowpipe and Task Scheduling.\n\nAutomated alerts and monitoring dashboards.\n\nAdditionally, calculate and include the cost consumed by the API for this call in the output, explicitly mentioning the cost in USD.\n\nEnsure the cost consumed by the API is mentioned with all decimal values included.\n\nInput :\n* For snowflake SQL scripts use below file : \n```%1$s``` \n",
                "expectedOutput": "1. Overview of Program:  \n   - Explain the purpose of the Snowflake SQL code in detail.  \n   - Describe how this implementation aligns with enterprise data warehousing and analytics.  \n   - Explain the business problem being addressed and its benefits.  \n   - Provide a high-level summary of Snowflake SQL components like Stored Procedures, Views, and Tables.  \n\n2. Code Structure and Design:  \n   - Explain the structure of the Snowflake SQL code in detail.  \n   - Describe key components like DDL, DML, Joins, Indexing, and Stored Procedures.  \n   - List the primary Snowflake SQL components such as Tables, Views, Stored Procedures, Joins, Aggregations, and Subqueries.  \n   - Highlight dependencies on Snowflake objects, performance tuning techniques, or third-party integrations.  \n\n3. Data Flow and Processing Logic:  \n   - Explain how data flows within the Snowflake SQL implementation.  \n   - List the source and destination tables, fields, and data types.  \n   - Explain the applied transformations, including filtering, joins, aggregations, and field calculations.  \n\n4. Data Mapping:  \n* Provide data mapping details, including transformations applied to the data in the below format:  \n* Target Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks  \n* Mapping column will have the details whether it's 1 to 1 mapping or the transformation rule or the validation rule  \n\n5. Performance Optimization Strategies:  \n   - Explain optimization techniques used in the Snowflake SQL implementation.  \n   - Describe strategies like Clustering Keys, Materialized Views, and Query Caching.  \n   - Explain how performance is improved using techniques like Micro-partitions, Automatic Scaling, and Warehouse Caching.  \n   - Provide real-world examples of optimization benefits.  \n\n6. Technical Elements and Best Practices:  \n   - Explain the technical elements involved in the Snowflake SQL code.  \n   - List Snowflake system dependencies such as Database Connections, Table Structures, and Workload Management.  \n   - Mention best practices like Efficient Joins, Query Tuning, and Data Clustering.  \n   - Specify additional Snowflake tools like Snowflake Query Profile, Streams, Tasks, and Time Travel.  \n   - Describe error handling, logging, and exception tracking methods.  \n\n7. Complexity Analysis:  \n   - Analyze and document the complexity based on the following:  \n   - Provide this in table format with two columns:\n\nCategory  |  Measurement  \n* Number of Lines: Count of lines in the SQL script.  \n* Tables Used: Number of tables referenced in the SQL script.  \n* Joins: Number of joins and the types of joins used (e.g., INNER JOIN, LEFT JOIN, CROSS JOIN).  \n* Temporary Tables: Number of CTEs or transient tables.  \n* Aggregate Functions: Number of aggregate functions like Window Functions.  \n* DML Statements: Number of DML statements by type like SELECT, INSERT, UPDATE, DELETE, MERGE, COPY INTO, etc.  \n* Conditional Logic: Number of conditional logic like CASE, IF-THEN, etc.  \n* SQL Query Complexity: Number of joins, subqueries, and stored procedures.  \n* Performance Considerations: Query execution time, warehouse utilization, and caching efficiency.  \n* Data Volume Handling: Number of records processed.  \n* Dependency Complexity: External dependencies such as Stored Procedures, Streams, or Tasks.  \n* Overall Complexity Score: Score from 0 to 100.  \n\n8. Assumptions and Dependencies:  \n   - List system prerequisites such as database connections, table structures, and access roles.  \n   - Mention infrastructure dependencies, including Snowflake warehouses, Google Cloud Storage, or BigQuery.  \n   - Note assumptions about data consistency, schema evolution, and workload management.  \n\n9. Key Outputs:  \n   - Describe final outputs such as Aggregated Reports, Tables, Views, or Data Exports.  \n   - Explain how outputs align with business goals and reporting needs.  \n   - Specify the storage format (e.g., Staging Tables, Production Tables, Parquet Files, External Data Sources).  \n\n10. Error Handling and Logging:  \n   - Explain methods used for error identification and management, such as:  \n     - Try-Catch mechanisms in Stored Procedures.  \n     - Snowflake Query History and Information Schema for tracking failures.  \n     - Retry mechanisms using Streams and Tasks.  \n     - Automated alerts and monitoring dashboards.  \n\n11. apiCost: float  // Cost consumed by the API for this call (in USD)\n* Ensure the cost consumed by the API is mentioned with all decimal values included.\n\n"
            }
        },
        {
            "agentName": "SNOWFLAKE_TO_BIGQUERY_ANALYZER",
            "model": "claude-3.5-sonnet",
            "tools": [],
            "task": {
                "description": "\"Please analyze the following Snowflake SQL query and provide an overview of its structure and elements while assessing the effort required to convert it to BigQuery\"\n\nNote:\n* Identify all tables explicitly mentioned in the query.\n* List all joins explicitly mentioned in the query. Include join types (e.g., INNER JOIN, LEFT JOIN) and the conditions used (e.g., ON, USING).\n* List all functions (e.g., aggregate, string, date functions) used in the query.\n* Assess syntax differences between the input Snowflake SQL query and its equivalent BigQuery code.\n* Identify any Snowflake-specific features such as QUALIFY, WINDOW, or ARRAY handling, and describe how they will need to be adapted to BigQuery.\n* Provide a clear and concise remark describing the notable differences or challenges in conversion.\n* Ensure accurate complexity assessment with proper justification in the description.\n* Ensure that the analysis strictly follows the format below.\n\nthe input is mentioned below:\n\n%1$s",
                "expectedOutput": "1. Overview:\nA high-level description of the SQL script\u2019s purpose and the primary objectives of the migration.\n\n2. Detailed Metrics:\n* Number of Lines: int, // total lines in the input Snowflake SQL query.\n* Tables Used: ['String', 'String'], // list of tables referenced in the query.\n* Joins: ['String', 'String'], // list of join types (e.g., INNER JOIN, LEFT JOIN).\n* Functions: ['String', 'String'], // list of functions used (e.g., aggregation, date, window, and Snowflake-specific functions).\n* DML List: ['String', 'String'], // list of DML statements (e.g., INSERT, UPDATE, DELETE, MERGE).\n\n3. Conversion Complexity:\nA complexity score on a scale of 0-100 for the difficulty of converting the Snowflake SQL to the target SQL platform.\n\n4. Conversion Description:\nA description of the conversion complexity, identifying areas that will require significant manual adjustments (e.g., QUALIFY handling, window function rewriting, or syntax differences).\n\n5. Manual Solution:\nA list of manual code changes that will be required for conversion:\n* Replacements for Snowflake-specific functions.\n* Modifications to syntax for target platform compatibility.\n* Workarounds for unsupported features.\n\n6. Number of Syntax Differences:\nThe number of syntax differences between the Snowflake SQL and the target SQL platform\u2019s version of the query.\n"
            }
        },
        {
            "agentName": "SNOWFLAKE_TO_BIGQUERY_PLAN",
            "model": "gpt-4o",
            "tools": [],
            "task": {
                "description": "You are tasked with providing a comprehensive effort estimate for testing the Bigquery converted from snowflake scripts. Follow these instructions to complete the task:\n\nINSTRUCTIONS:\n1. Review the analysis of snowflake script file, noting syntax differences when converting to Bigquery and areas requiring manual intervention.\n2. Consider the pricing information for GCP Bigquery environment \n4. Calculate the estimated cost of running the converted Bigquery code:\n   a. Use the pricing information and data volume to determine the code cost.\n   b. the number of code and the data processing done with the base tables and temporary tables\n5. Estimate the code fixing and data recon testing effort required:\n\nINPUT :\n* Take the previous SNOWFLAKE_TO_BIGQUERY_ANALYZER agent output as  input\n* For the input Snowflake script use this file : ```%1$s```\n* For the input  Bigquery Environment Details for GCP  use this file : ```%2$s```",
                "expectedOutput": "1. Cost Estimation\n   2.1 Bigquery Runtime Cost \n         - provide the calculation breakup of the cost and the reasons\n\n2. Code Fixing  and Testing Effort Estimation\n   2.1 Bigquery code manual code fixes and unit testing effort covering the various temp tables, calculations in hours\n   2.2 Output validation effort comparing the output from Snowflake script and Bigquery script in hours\n   2.3 Total Estimated Effort in Hours\n         - provide the reason for the total effort hours and how it was arrived\n\n* Include the cost consumed by the API for this call in the output.\n* Ensure the cost consumed by the API is reported as a floating-point value with currency explicitly mentioned as USD (e.g., apiCost: actual cost )."
            }
        }
    ]
}