{
    "pipeline": {
        "pipelineId": 8000,
        "name": "DI_BigQuery_Dim_Data_Engineer_Gold_Layer",
        "description": "BigQuery Gold dimension layer pipeline",
        "createdAt": "2025-11-03T18:05:22.462+00:00",
        "pipeLineAgents": [
            {
                "serial": 1,
                "agent": {
                    "id": 10351,
                    "name": "DI_BigQuery_Gold_Dim_DE_Pipeline",
                    "role": "Senior Data Engineer",
                    "goal": "To efficiently move Silver Layer data into Gold Layer **dimension tables** in **Google BigQuery**, ensuring high-quality, standardized, and deduplicated reference data with robust logging and error handling.",
                    "backstory": "Dimension tables form the backbone of analytical reporting. This task ensures that clean, conformed, and business-aligned dimensions are created in the Gold Layer for consistent analytics and BI consumption.",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-11-05T11:08:41.700155",
                    "llm": {
                        "modelDeploymentName": "gemini-2.5-pro",
                        "model": "gemini-2.5-pro",
                        "modelType": "Generative",
                        "aiEngine": "GoogleAI",
                        "topP": 0.949999988079071,
                        "maxToken": 64000,
                        "temperature": 0.30000001192092896,
                        "gcpProjectId": "genai-platform-431215",
                        "gcpLocation": "us-central1"
                    },
                    "embedding": [
                        {
                            "aiEngine": "AzureOpenAI",
                            "chroma_end_point": "http://chromadb.da.svc.cluster.local",
                            "chroma_port": "80",
                            "index_collection": "bigquery_best_practices",
                            "embedding_model": "text-embedding-ada-002",
                            "embedding_deployment_name": "ava-text-embedding-ada-002",
                            "embedding_api_version": "2024-09-01-preview",
                            "embedding_api_key": "****MASKED****",
                            "embedding_azure_endpoint": "https://da-cognitive-account-demo.openai.azure.com/"
                        }
                    ],
                    "task": {
                        "description": " You need to fetch the input file directly from the GitHub repository using the GitHub Reader tool. After processing and generating the output, write the final result back to the same GitHub repository using the provided GitHub credentials {{Github_Details}}.  \nEnsure both read and write operations are performed securely using these credentials. \n\nThe agent must create a **BigQuery Stored Procedure** that:\n\n* Reads reference data from Silver tables.\n* Applies business transformations to standardize and deduplicate records.\n* Generates surrogate keys and manages hierarchical relationships.\n* Logs transformations, errors, and processing metrics.\n* Ensures dimension structures match the Gold Layer DDL.\n* Read the knowledge base file to find the limitations and best practices for BigQuery. Use it as a reference before generating the output.\n---\n\n### **Instructions**\n\n1. **Extract Data from Silver Layer:**\n\n   * Read data from existing Silver tables in BigQuery.\n   * Use fully qualified names like `project.silver_dataset.table_name`.\n   * Convert all table and column names to lowercase.\n\n2. **Apply Transformations for Dimension Tables:**\n\n   * Generate surrogate keys using `GENERATE_UUID()` or sequence logic.\n   * Map hierarchies (e.g., category\u2013subcategory).\n   * Deduplicate and standardize string attributes (trim, lower, proper-case).\n   * Align transformations with business rules defined in the input\n\n3. **Error Handling and Validation:**\n\n   * Validate key fields for null or duplicate values.\n   * Log invalid rows into a **gold dimension error table**:\n\n     ```\n     gold_dataset.dim_error_log\n     (error_id, source_table, error_description, record_data, error_timestamp, processed_by)\n     ```\n\n4. **Audit Logging:**\n\n   * Maintain audit logs for transformation runs:\n\n     ```\n     gold_dataset.dim_audit_log\n     (record_id, source_table, load_timestamp, total_records, valid_records, invalid_records, status, processed_by)\n     ```\n\n5. **Optimization:**\n\n   * Use partitioning on business-effective dates.\n   * Use clustering on surrogate keys for query performance.\n   * Store tables in **columnar format** with efficient compression.\n\n6. **Stored Procedure Structure:**\n\n   * Procedure name format:\n\n     ```\n     sp_silver_to_gold_dim_<table_name>\n     ```\n   * Use `DECLARE`, `BEGIN\u2026EXCEPTION\u2026END` structure.\n   * Capture `@@error.message` for logging failures.\n\n---\n\n### **Input:**\n* Model Physical Silver Layer : {{Silver_Layer_DDL}}\n* Model Physical Gold Layer : {{Gold_Layer_DDL}}\n* Gold Dimension table Transformation Data Mapping : {{Gold_Layer_Dim_Data_Mapping}}",
                        "expectedOutput": "1. Complete **BigQuery Stored Procedure** for Dimension table creation.\n2. Embedded audit and error-logging logic.\n"
                    },
                    "maxIter": 0,
                    "maxRpm": 0,
                    "maxExecutionTime": 0,
                    "tools": [],
                    "userTools": [
                        {
                            "toolId": 300,
                            "toolName": "DI_Github_File_Writer_Z",
                            "toolClassName": "GitHubFileWriterTool",
                            "toolClassDef": "from crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\nimport base64\nimport requests\nimport urllib3\nimport logging\nimport re\nfrom typing import Type, Any\n\n# ---------------------------------\n# SSL & Logging Configuration\n# ---------------------------------\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\",\n    filename=\"github_file_writer.log\",\n)\nlogger = logging.getLogger(\"GitHubFileWriterTool\")\n\n\n# ---------------------------------\n# Input Schema\n# ---------------------------------\nclass GitHubFileWriterSchema(BaseModel):\n    repo: str = Field(..., description=\"GitHub repository in 'owner/repo' format\")\n    branch: str = Field(..., description=\"Branch name (e.g., 'main')\")\n    token: str = Field(..., description=\"GitHub Personal Access Token\")\n    folder_name: str = Field(..., description=\"Name of the folder to create inside the repository\")\n    file_name: str = Field(..., description=\"Name of the file to create or update in the folder\")\n    content: str = Field(..., description=\"Text content to upload into the GitHub file\")\n\n\n# ---------------------------------\n# Main Tool Class\n# ---------------------------------\nclass GitHubFileWriterTool(BaseTool):\n    name: str = \"GitHub File Writer Tool\"\n    description: str = \"Creates or updates files in a GitHub repository folder\"\n    args_schema: Type[BaseModel] = GitHubFileWriterSchema\n\n    api_url_template: str = \"https://api.github.com/repos/{repo}/contents/{path}\"\n\n    def _sanitize_path_component(self, component: str) -> str:\n        \"\"\"Remove invalid GitHub path characters.\"\"\"\n        sanitized = re.sub(r'[\\\\*?:\"<>|]', '_', component)\n        sanitized = re.sub(r'\\.\\.', '_', sanitized)\n        sanitized = sanitized.lstrip('./\\\\')\n        return sanitized if sanitized else \"default\"\n\n    def _validate_content(self, content: str) -> str:\n        \"\"\"Ensure valid string content within 10MB limit.\"\"\"\n        if not isinstance(content, str):\n            logger.warning(\"Content is not a string. Converting to string.\")\n            content = str(content)\n\n        max_size = 10 * 1024 * 1024  # 10 MB\n        if len(content.encode('utf-8')) > max_size:\n            logger.warning(\"Content exceeds 10MB limit. Truncating.\")\n            content = content[:max_size]\n\n        return content\n\n    def create_file_in_github(self, repo: str, branch: str, token: str,\n                              folder_name: str, file_name: str, content: str) -> str:\n        \"\"\"Create or update a file in GitHub repository.\"\"\"\n        sanitized_folder = self._sanitize_path_component(folder_name)\n        sanitized_file = self._sanitize_path_component(file_name)\n        validated_content = self._validate_content(content)\n\n        path = f\"{sanitized_folder}/{sanitized_file}\"\n        url = self.api_url_template.format(repo=repo, path=path)\n        headers = {\"Authorization\": f\"token {token}\", \"Content-Type\": \"application/json\"}\n\n        # Encode content\n        encoded_content = base64.b64encode(validated_content.encode()).decode()\n\n        # Check file existence to get SHA (for updating)\n        sha = None\n        try:\n            response = requests.get(url, headers=headers, params={\"ref\": branch}, verify=False)\n            if response.status_code == 200:\n                sha = response.json().get(\"sha\")\n        except Exception as e:\n            logger.error(f\"Failed to check file existence: {e}\", exc_info=True)\n\n        payload = {\"message\": f\"Add or update file: {sanitized_file}\",\n                   \"content\": encoded_content, \"branch\": branch}\n        if sha:\n            payload[\"sha\"] = sha  # Required for updating\n\n        # Upload or update file\n        try:\n            put_response = requests.put(url, json=payload, headers=headers, verify=False)\n            if put_response.status_code in [200, 201]:\n                logger.info(f\"\u2705 File '{sanitized_file}' uploaded successfully to {repo}/{sanitized_folder}\")\n                return f\"\u2705 File '{sanitized_file}' uploaded successfully to GitHub in folder '{sanitized_folder}'.\"\n            else:\n                logger.error(f\"GitHub API Error: {put_response.text}\")\n                return f\"\u274c Failed to upload file. GitHub API error: {put_response.text}\"\n        except Exception as e:\n            logger.error(f\"Failed to upload file: {e}\", exc_info=True)\n            return f\"\u274c Exception while uploading file: {str(e)}\"\n\n    # ------------------------------------------------------\n    # Required method for CrewAI Tool execution\n    # ------------------------------------------------------\n    def _run(self, repo: str, branch: str, token: str,\n             folder_name: str, file_name: str, content: str) -> Any:\n        \"\"\"Main execution method.\"\"\"\n        return self.create_file_in_github(repo, branch, token, folder_name, file_name, content)\n\n\n# ---------------------------------\n# Generalized Main (User-Parameterized)\n# ---------------------------------\nif __name__ == \"__main__\":\n    print(\"\ud83d\udd27 GitHub File Writer Tool - Interactive Mode\\n\")\n    repo = input(\"Enter GitHub repository (owner/repo): \").strip()\n    branch = input(\"Enter branch name (e.g., main): \").strip()\n    token = input(\"Enter your GitHub Personal Access Token: \").strip()\n    folder_name = input(\"Enter folder name: \").strip()\n    file_name = input(\"Enter file name (e.g., example.txt): \").strip()\n    print(\"\\nEnter the content for your file (end with a blank line):\")\n    lines = []\n    while True:\n        line = input()\n        if line == \"\":\n            break\n        lines.append(line)\n    content = \"\\n\".join(lines)\n\n    tool = GitHubFileWriterTool()\n    result = tool._run(repo=repo, branch=branch, token=token,\n                       folder_name=folder_name, file_name=file_name, content=content)\n    print(\"\\nResult:\", result)\n",
                            "isApproved": false
                        },
                        {
                            "toolId": 344,
                            "toolName": "DI_GitHub_File_Reader_Z",
                            "toolClassName": "GitHubFileReaderTool",
                            "toolClassDef": "from crewai.tools import BaseTool\nfrom pydantic import BaseModel, Field\nimport base64\nimport requests\nimport logging\nfrom typing import Type, Any, List, Dict\n\n# Setup logging for the GitHub File Reader Tool\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    filename='github_file_reader.log'\n)\nlogger = logging.getLogger('GitHubFileReaderTool')\n\nclass GitHubFileReaderSchema(BaseModel):\n    \"\"\"Input schema for the GitHubFileReaderTool.\"\"\"\n    repo: str = Field(..., description=\"GitHub repository in the format 'owner/repo'\")\n    file_paths: List[str] = Field(..., description=\"List of file paths in the repository\")\n    branch: str = Field(..., description=\"Branch name to read the files from (e.g., 'main')\")\n    token: str = Field(..., description=\"GitHub personal access token for authorization\")\n\nclass GitHubFileReaderTool(BaseTool):\n    name: str = \"GitHub File Reader Tool\"\n    description: str = \"Reads multiple files from a GitHub repository based on user inputs.\"\n    args_schema: Type[BaseModel] = GitHubFileReaderSchema\n\n    api_url_template: str = \"https://api.github.com/repos/{repo}/contents/{file_path}\"\n\n    def fetch_file_from_github(self, repo: str, file_path: str, branch: str, token: str) -> str:\n        \"\"\"Fetches a file content from GitHub.\"\"\"\n        url = self.api_url_template.format(repo=repo, file_path=file_path)\n        headers = {\n            \"Authorization\": f\"token {token}\",\n            \"Accept\": \"application/vnd.github.v3+json\"\n        }\n        params = {\"ref\": branch}\n\n        try:\n            logger.info(f\"Fetching file '{file_path}' from repo '{repo}' on branch '{branch}'\")\n            response = requests.get(url, headers=headers, params=params)\n            response.raise_for_status()\n\n            file_data = response.json()\n            if \"content\" not in file_data:\n                raise ValueError(f\"\u274c Error: Path '{file_path}' might be a directory or missing content.\")\n\n            decoded_content = base64.b64decode(file_data['content']).decode('utf-8')\n            logger.info(f\"\u2705 Successfully fetched file '{file_path}'.\")\n            return decoded_content\n\n        except Exception as e:\n            logger.error(f\"Failed to fetch file '{file_path}': {str(e)}\", exc_info=True)\n            raise\n\n    def _run(self, repo: str, file_paths: List[str], branch: str, token: str) -> Dict[str, Any]:\n        \"\"\"Main execution logic.\"\"\"\n        all_files_content = {}\n        for file_path in file_paths:\n            try:\n                content = self.fetch_file_from_github(repo, file_path, branch, token)\n                all_files_content[file_path] = {\"status\": \"success\", \"content\": content}\n            except Exception as e:\n                all_files_content[file_path] = {\"status\": \"error\", \"message\": str(e)}\n\n        return all_files_content\n\n\n# Example Usage\nif __name__ == '__main__':\n    github_token = \"YOUR_GITHUB_TOKEN\"\n    github_repo = \"owner/repository-name\"\n    github_branch = \"main\"\n    github_files = [\n        \"path/to/file1.txt\",\n        \"path/to/file2.sql\",\n        \"path/to/file3.json\"\n    ]\n\n    if github_token == \"YOUR_GITHUB_TOKEN\":\n        print(\"\u26a0\ufe0f Please replace the placeholder values before running.\")\n    else:\n        reader_tool = GitHubFileReaderTool()\n        result = reader_tool.run(\n            repo=github_repo,\n            file_paths=github_files,\n            branch=github_branch,\n            token=github_token\n        )\n\n        for file, details in result.items():\n            print(f\"\\nFile: {file}\")\n            if details['status'] == 'success':\n                print(f\"Content:\\n{details['content'][:200]}...\")  # print first 200 characters\n            else:\n                print(f\"Error: {details['message']}\")\n",
                            "isApproved": false
                        }
                    ],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 2,
                "agent": {
                    "id": 10363,
                    "name": "DI_BigQuery_Unit_Test_Case",
                    "role": "Senior Data Engineer",
                    "goal": "Validate the correctness, reliability, and performance of data pipeline components running on Google Cloud Platform (GCP) by generating comprehensive unit test scripts and test case documentation.\nThe agent must automatically detect whether the input code is Python or BigQuery SQL / Stored Procedure and generate the appropriate test suite accordingly.",
                    "backstory": "\n\nData pipelines across the Bronze \u2192 Silver \u2192 Gold layers in GCP involve both Python (for ingestion/orchestration) and BigQuery SQL (for transformation and aggregation).\nEnsuring correctness across both environments is critical to prevent data quality issues and maintain trust in analytical insights.\nThis agent provides automated unit test scripts tailored for the respective code type \u2014 either Python or BigQuery SQL \u2014 along with clear test cases and audit information.",
                    "verbose": true,
                    "allowDelegation": false,
                    "updatedAt": "2025-11-05T09:21:56.462995",
                    "llm": {
                        "modelDeploymentName": "gemini-2.5-pro",
                        "model": "gemini-2.5-pro",
                        "modelType": "Generative",
                        "aiEngine": "GoogleAI",
                        "topP": 0.949999988079071,
                        "maxToken": 64000,
                        "temperature": 0.30000001192092896,
                        "gcpProjectId": "genai-platform-431215",
                        "gcpLocation": "us-central1"
                    },
                    "task": {
                        "description": "You need to fetch the input file directly from the GitHub repository using the GitHub Reader tool. After processing and generating the output, write the final result back to the same GitHub repository using the provided GitHub credentials {{Github_Details}}.  \nEnsure both read and write operations are performed securely using these credentials.  \n\nYou are tasked with creating **unit test cases** and a **corresponding test script** for the given code.\nThe agent should **detect the code type automatically** and behave as follows:\n\n#### **If the input code is Python**\n\n* Generate a **Pytest-based test suite** that validates:\n  * Functionality of individual functions or classes\n  * Handling of edge cases (empty data, nulls, invalid inputs)\n  * Exception and error scenarios\n  * Integration points (e.g., GCS, BigQuery clients) using mocks\n* Follow **pytest** structure and ensure readability and modularity.\n* Include setup and teardown fixtures for initializing dependencies (e.g., mock GCP clients).\n* Apply **PEP8** coding style.\n\n#### **If the input code is BigQuery SQL / Stored Procedure**\n\n* Generate a **BigQuery SQL-based test suite** (assertion script or stored procedure harness).\n* The test script should:\n  * Create **temporary tables** or **CTEs** with mock input data.\n  * Run the provided SQL logic or stored procedure.\n  * Validate outcomes using **`ASSERT` statements** or **conditional checks**.\n  * Log test results (pass/fail, timestamp, error message) into a `test_audit_log` table if required.\n  * Cover scenarios such as null handling, deduplication, aggregation accuracy, and joins.\n* Follow BigQuery SQL syntax best practices and avoid unsupported features.\n\n---\n\n### **Instructions**\n\n1. **Auto-detect input type**:\n   * If the code starts with Python imports, class/function definitions, or uses GCP Python SDKs \u2192 treat as **Python**.\n   * If the code starts with `CREATE`, `SELECT`, `CALL`, `DECLARE`, or other SQL keywords \u2192 treat as **BigQuery SQL / Stored Procedure**.\n\n2. **Generate:**\n   * A **comprehensive test case table**:\n     * Test Case ID\n     * Test Case Description\n     * Input Scenario\n     * Expected Outcome\n     * Validation Logic\n   * A **complete test script**:\n     * For Python \u2192 a `.py` Pytest script\n     * For SQL \u2192 a `.sql` test suite or stored procedure\n\n3. **Test Case Coverage Must Include:**\n   * Happy path validation\n   * Null / empty / invalid input cases\n   * Data type or schema mismatches\n   * Error or exception handling\n   * Performance validation (optional lightweight check)\n\n### **Input**\n\nUse the output code generated from the previous agent (either **Python ingestion/processing code** or **BigQuery SQL stored procedure**) as input.",
                        "expectedOutput": "1. **Test Case Summary Table**\n   | Test Case ID | Test Description | Input Scenario | Expected Output | Validation Logic |\n\n2. **Unit Test Script**\n   * For **Python** \u2192 Fabric-agnostic `pytest` test script, runnable in any GCP environment.\n   * For **SQL** \u2192 Executable BigQuery SQL test suite or stored procedure harness."
                    },
                    "maxIter": 0,
                    "maxRpm": 0,
                    "maxExecutionTime": 0,
                    "tools": [],
                    "userTools": [],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 3,
                "agent": {
                    "id": 10364,
                    "name": "DI_BigQuery_DE_Pipeline_Reviewer",
                    "role": "Senior Data Engineer",
                    "goal": "To validate and review the output generated by the **DE Developer agent** within the workflow.\nEnsure the code is **fully compatible with Google Cloud Platform (GCP)** \u2014 specifically **BigQuery** and **Python environments** \u2014 and validate correctness, performance, syntax, and transformation accuracy.\nAdditionally, provide a **final verdict** on whether the code is suitable for deployment in BigQuery.",
                    "backstory": "You are responsible for reviewing the outputs produced by upstream data pipeline agents that build code for GCP data processing.\nDepending on the workflow:\n* **Source \u2192 Bronze** uses **Python-based ingestion code** (GCS \u2192 BigQuery).\n* **Bronze \u2192 Silver / Silver \u2192 Gold** uses **BigQuery SQL or Stored Procedures** for transformations.\nThis agent ensures the output is:\n* Technically correct\n* Syntactically valid\n* Compatible with BigQuery standards\n* Optimized and reliable for production execution",
                    "verbose": true,
                    "allowDelegation": false,
                    "updatedAt": "2025-11-05T09:24:46.616768",
                    "llm": {
                        "modelDeploymentName": "gemini-2.5-pro",
                        "model": "gemini-2.5-pro",
                        "modelType": "Generative",
                        "aiEngine": "GoogleAI",
                        "topP": 0.949999988079071,
                        "maxToken": 64000,
                        "temperature": 0.30000001192092896,
                        "gcpProjectId": "genai-platform-431215",
                        "gcpLocation": "us-central1"
                    },
                    "embedding": [
                        {
                            "aiEngine": "AzureOpenAI",
                            "chroma_end_point": "http://chromadb.da.svc.cluster.local",
                            "chroma_port": "80",
                            "index_collection": "bigquery_best_practices",
                            "embedding_model": "text-embedding-ada-002",
                            "embedding_deployment_name": "ava-text-embedding-ada-002",
                            "embedding_api_version": "2024-09-01-preview",
                            "embedding_api_key": "****MASKED****",
                            "embedding_azure_endpoint": "https://da-cognitive-account-demo.openai.azure.com/"
                        }
                    ],
                    "task": {
                        "description": " You need to fetch the input file directly from the GitHub repository using the GitHub Reader tool. After processing and generating the output, write the final result back to the same GitHub repository using the provided GitHub credentials {{Github_Details}}.  \nEnsure both read and write operations are performed securely using these credentials. \nGiven the output code (either **Python** or **BigQuery SQL / Stored Procedure**) from the DE Developer agent, review and validate across multiple dimensions.\nUse **\u2705 for correct implementation** and **\u274c for issues**.\nProvide a **summary table**, detailed findings, and a **final verdict** on whether the code is ready for production execution.\nRead the knowledge base file to find the limitations and best practices for BigQuery. Use it as a reference before generating the output.\n\n### **Input Type Auto-Detection**\n1. If the code starts with **Python syntax** (`import`, `def`, `class`, `pandas`, `google.cloud`, etc.) \u2192 treat as **Python code**.\n2. If the code starts with **SQL syntax** (`CREATE`, `SELECT`, `CALL`, `DECLARE`, etc.) \u2192 treat as **BigQuery SQL / Stored Procedure**.\n\n### **Validation Categories**\n\n#### 1. \u2705 Validation Against Metadata\n* Ensure that the code aligns with the **source and target schema** definitions.\n* Verify **column names**, **data types**, and **transformation rules** are consistent with the mapping file.\n* Highlight any **mismatched fields**, **missing columns**, or **incorrect datatypes**.\n\n#### 2. \u2705 Compatibility with BigQuery Environment\n* Ensure the code uses **BigQuery-supported syntax and functions** only.\n* Check for **unsupported operations** or **functions not available in BigQuery**.\n* Reference the **BigQuery knowledge base file** (limitations, unsupported functions, etc.).\n* Suggest **alternative syntax** or **workarounds** if issues exist.\n\n#### 3. \u2705 Validation of Join and Query Operations\n* Review all **JOIN**, **UNION**, and **CTE** operations.\n* Verify that join keys exist in both source and target datasets.\n* Ensure **data type compatibility** between join columns.\n* Identify **unnecessary cross joins**, **cartesian products**, or **missing ON conditions**.\n\n#### 4. \u2705 Syntax and Code Review\n* For **Python**: check indentation, function structure, and syntax validity.\n* For **SQL**: ensure statements are syntactically correct and BigQuery-compliant.\n* Detect any undefined references (tables, functions, aliases).\n* Suggest fixes for syntax inconsistencies.\n\n#### 5. \u2705 Compliance with Development Standards\n* Ensure modular and readable structure.\n* Validate use of **naming conventions**, **comments**, and **error handling**.\n* For Python: confirm PEP8 compliance, proper logging, and use of context managers.\n* For SQL: ensure consistent indentation, alias naming, and logical flow of queries.\n\n#### 6. \u2705 Validation of Transformation Logic\n* Check transformation rules and calculations against expected mapping.\n* Validate use of expressions, aggregations, and derived columns.\n* Identify incorrect transformation logic or missing derived fields.\n* Ensure **no data duplication** or **loss** occurs due to transformation design.\n\n#### 7. \u2705 Optimization and Performance\n* Suggest query optimizations (reduce shuffle, avoid SELECT *, remove redundant CTEs).\n* For SQL: recommend **partitioning**, **clustering**, or **materialized views** if beneficial.\n* For Python: highlight unnecessary loops or inefficient operations.\n\n#### 8. \u2705 Error Reporting and Recommendations\n* Log all detected issues, grouped by **severity (High, Medium, Low)**.\n* Provide **clear recommendations** for resolving them.\n* End with a **final verdict**:\n  * \ud83d\udfe2 **Approved for BigQuery Execution**\n  * \ud83d\udfe1 **Partially Approved (Fix Required)**\n  * \ud83d\udd34 **Not Approved (Major Issues Found)**\n\n* Read the knowledge base file to find the limitations and best practices for BigQuery. Use it as a reference before generating the output.",
                        "expectedOutput": "1. **Validation Summary Table**\n   | Category                    | Review Status | Comments / Findings |\n   | --------------------------- | ------------- | ------------------- |\n   | Validation Against Metadata | \u2705 / \u274c         | Description         |\n   | Compatibility with BigQuery | \u2705 / \u274c         | Description         |\n   | Join / Query Operations     | \u2705 / \u274c         | Description         |\n   | Syntax Review               | \u2705 / \u274c         | Description         |\n   | Standards Compliance        | \u2705 / \u274c         | Description         |\n   | Transformation Logic        | \u2705 / \u274c         | Description         |\n   | Optimization Check          | \u2705 / \u274c         | Description         |\n\n2. **Detailed Findings**\n   * Bullet list of errors or observations under each section\n   * Highlight problematic SQL segments or Python code blocks (if any)\n   * Include reasoning and fix suggestions\n\n3. **Final Verdict**\n   ```\n   Final Verdict: \ud83d\udfe2 Approved for BigQuery Execution\n   (or \ud83d\udfe1 / \ud83d\udd34 based on findings)"
                    },
                    "maxIter": 0,
                    "maxRpm": 0,
                    "maxExecutionTime": 0,
                    "tools": [],
                    "userTools": [],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            }
        ],
        "enableAgenticMemory": false,
        "levelId": 99,
        "org": "Ascendion",
        "orgId": 1,
        "domain": "Data&Insights",
        "domainId": 96,
        "projectId": 98,
        "project": "AllProjects",
        "teamId": 99,
        "team": "AVA Team",
        "callbacks": []
    }
}