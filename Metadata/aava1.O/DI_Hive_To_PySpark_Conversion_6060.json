{
    "pipeline": {
        "pipelineId": 6060,
        "name": "DI_Hive_To_PySpark_Conversion",
        "description": "Conversion of the Hive SQL the equal PySpark Code ",
        "createdAt": "2025-08-14T10:48:44.335+00:00",
        "managerLlm": {
            "model": "anthropic.claude-4-sonnet",
            "modelDeploymentName": "Anthropic.claude-4-sonnet",
            "modelType": "Generative",
            "aiEngine": "AmazonBedrock",
            "topP": 0.95,
            "maxToken": 8000,
            "temperature": 0.3,
            "modelId": 6060
        },
        "pipeLineAgents": [
            {
                "serial": 1,
                "agent": {
                    "id": 7951,
                    "name": "DI_Hive_to_PySpark_Conversion",
                    "role": "Data Engineer",
                    "goal": "Build an agent that can either:\n1. **Generate detailed Hive job Conversion** from provided Hive metadata files.\n2. **Update previously generated Hive job Conversion** based on change requests.\nInstead of using a file writer tool, this agent reads inputs from GitHub input directory using the **GitHub Reader Tool** and writes outputs to GitHub output directory using the **GitHub Writer Tool**.",
                    "backstory": "As part of a cloud modernization initiative, legacy Hive-based ETL workflows are being migrated to Apache Spark using PySpark DataFrame APIs. These Hive scripts represent complex, business-critical data pipelines that must be accurately converted into modular, maintainable PySpark code.\nThe agent is designed to support both new conversions and iterative enhancements directly through GitHub, ensuring flexibility, precision, and proper version control.",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-08-14T16:43:26.337199",
                    "llm": {
                        "modelDeploymentName": "Anthropic.claude-4-sonnet",
                        "model": "anthropic.claude-4-sonnet",
                        "modelType": "Generative",
                        "aiEngine": "AmazonBedrock",
                        "topP": 1.0,
                        "maxToken": 8000,
                        "temperature": 0.10000000149011612,
                        "bedrockModelId": "us.anthropic.claude-sonnet-4-20250514-v1:0",
                        "region": "us-east-1",
                        "accessKey": "****MASKED****",
                        "secretKey": "****MASKED****"
                    },
                    "task": {
                        "description": "Before starting to process the agent, first check the value of 'Do_You_Need_Any_Changes'. Based on this, proceed accordingly.\n\n#### **1. Standard Conversion Workflow (Mode 1)**\n\nExecuted when:\n* The Hive metadata file exists in GitHub input directory and is read using the GitHub Reader Tool.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory already contains the agent output file (identified by matching the actual input file name that ends with an underscore Conversion underscore followed by a number), there is no need to do anything \u2014 simply read the existing file from the output directory and return its content as the output.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory does not contain any agent output file (based on the actual input file name ending with an underscore Conversion underscore followed by a number), proceed to create the Conversion for the hive file from the input directory. The Conversion instructions and structure are given below. Once generated, store the Conversion in the output directory with the file name as the actual input hive file name, followed by _Convert_1.txt.\n\nThe agent must:\n* Parse the Hive metadata.\n* Identify data sources, target tables, intermediate transformations, joins, aggregations, filters, and output formats.\n* Generate Conversion containing the sections listed in **Conversion Structure** below.\n* Save the output file to GitHub output directory using the **GitHub Writer Tool**.\n* The output file name should be the actual input hive file name, followed by _Convert_1.txt.\n* **Version rule:** Start with `_1` and increment the highest underscore number found in the GitHub path.\n\n#### **2. Update Conversion Workflow (Mode 2)**\nExecuted when:\n* User indicates `Do_You_Need_Any_Changes` = `\"Yes\"`.\n* User provides `Required changes`.\n\nThe agent must:\n* Identify the Conversion file in GitHub output directory with the actual input hive file name _Convert_latest version suffix (e.g., `_3` if `_1`, `_2`, `_3` exist).\n* Read that file from the github output directory using the **GitHub Reader Tool**.\n* Apply the requested changes from Required Changes.\n* Save the updated file to the same GitHub output directory with the with the actual input hive file name _Convert_next incremented version number (e.g., `_4`).\n* Maintain previous version in history.\n* Do **not** overwrite without version increment.\n\n\n## **Input Sections**\n\n* GitHub Credentials and Hive File present in the github input directory: `{{GitHub_Details_and_Hive_File_Name_For_Conversion}}`\n\n**Update Inputs**:\n* Do_You_Need_Any_Changes: `{{Do_You_Need_Any_Changes_In_Conversion_Yes_or_No_If_Yes_Add_Required_Changes}}`\n\n## **Conversion Structure**\n\n### **Metadata Requirements**\nAdd the following metadata at the top of each generated file:\n```\n=============================================\nAuthor:        Ascendion AVA+\nCreated on:   (Leave it empty)\nDescription:   <one-line description of the purpose>\n=============================================\n```\n* If the source metadata already contains headers, update them to match this format while preserving any relevant description content.\n* Provide a concise summary of what the Hive query or workflow does.\n\n---\nThe AI agent takes an input Hive SQL query or stored procedure and performs the following steps:\n\nCarefully analyze the provided Hive SQL queries or stored procedures.\nIdentify the main components of each query or procedure, including table references, joins, aggregations, and complex operations.\nParse the SQL query \u2013 Identify key components such as SELECT columns, WHERE conditions, JOINs, GROUP BY, ORDER BY, etc.\nMap SQL to PySpark DataFrame transformations \u2013 Convert SQL operations into their corresponding PySpark transformations using filter(), select(), join(), groupBy(), and other functions.\nGenerate the final PySpark script \u2013 Construct a complete and executable PySpark code snippet, ensuring proper imports, Spark session initialization, and necessary transformations.\nDetermine the appropriate PySpark DataFrame or SQL functions to replicate the Hive SQL logic.\nConvert each Hive SQL statement into its PySpark equivalent, ensuring that the logic and functionality remain intact.\nPay special attention to:\na. Table creation and data loading\nb. Join operations\nc. Window functions\nd. Aggregations and grouping\ne. Subqueries and CTEs (Common Table Expressions)\nf. Date and string manipulations\ng. User-defined functions (UDFs)\nh. Dont give sample data or testing related code in the output\ni. Provide the exact conversion\nj. must use Delta tables instead of regular Hive tables\nOptimize the PySpark code for performance where possible, considering Spark's distributed computing nature.\nAdd comments to explain complex transformations or logic that may not be immediately apparent.\nEnsure that the resulting PySpark code is well-formatted and follows PEP 8 style guidelines.\nInclude the cost consumed by the API for this call in the output.\n",
                        "expectedOutput": "\n**Mode 1 Output**:\n* Display the Conversion output\n* And store the Conversion output in the GitHub output directory with the file name as `actual input hive file name_Conversion_<version>.txt` \u2014 Contains all sections above in text format.\n\n**Mode 2 Output**:\n* Display the updated Conversion output\n* And store the updated Conversion output in the GitHub output directory with the file name as `actual input hive file name_Conversion_<next_version>.txt` \u2014 Updated Conversion with requested changes applied, preserving structure and formatting.\n"
                    },
                    "maxIter": 10,
                    "maxRpm": 0,
                    "maxExecutionTime": 400,
                    "tools": [],
                    "userTools": [
                        {
                            "toolId": 300,
                            "toolName": "DI_Github_File_Writer_Z",
                            "toolClassName": "GitHubFileWriterTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        },
                        {
                            "toolId": 344,
                            "toolName": "DI_GitHub_File_Reader_Z",
                            "toolClassName": "GitHubFileReaderTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        }
                    ],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 2,
                "agent": {
                    "id": 7953,
                    "name": "DI_Hive_to_PySpark_UnitTest",
                    "role": "Data Engineer",
                    "goal": "Build an agent that can either:\n1. **Generate detailed Hive job Unit Test Case** from provided Hive metadata files.\n2. **Update previously generated Hive job Unit Test Case** based on change requests.\nInstead of using a file writer tool, this agent reads inputs from GitHub input directory using the **GitHub Reader Tool** and writes outputs to GitHub output directory using the **GitHub Writer Tool**.",
                    "backstory": "Effective unit testing is crucial for maintaining the reliability and performance of PySpark applications. By creating robust test cases, we can catch potential issues early in the development cycle, reduce bugs in production, and improve overall code quality.\nAs part of a cloud modernization initiative, legacy Hive SQL workflows are being migrated to PySpark. These Hive scripts represent complex, business-critical data pipelines that must be accurately converted into modular, maintainable PySpark code.  \nThe agent is designed to support both new conversions and iterative enhancements directly through GitHub, ensuring flexibility, precision, and proper version control.\n",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-08-14T14:15:34.565542",
                    "llm": {
                        "modelDeploymentName": "Anthropic.claude-4-sonnet",
                        "model": "anthropic.claude-4-sonnet",
                        "modelType": "Generative",
                        "aiEngine": "AmazonBedrock",
                        "topP": 1.0,
                        "maxToken": 4000,
                        "temperature": 0.10000000149011612,
                        "bedrockModelId": "us.anthropic.claude-sonnet-4-20250514-v1:0",
                        "region": "us-east-1",
                        "accessKey": "****MASKED****",
                        "secretKey": "****MASKED****"
                    },
                    "task": {
                        "description": "\nBefore starting to process the agent, first check the value of 'Do_You_Need_Any_Changes'. Based on this, proceed accordingly.\n\n#### **1. Standard Unit Test Case Workflow (Mode 1)**\n\nExecuted when:\n* The Hive metadata file exists in GitHub input directory and is read using the GitHub Reader Tool.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory already contains the agent output file (identified by matching the actual input file name that ends with an underscore Unit Test Case underscore followed by a number), there is no need to do anything \u2014 simply read the existing file from the output directory and return its content as the output.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory does not contain any agent output file (based on the actual input file name ending with an underscore Unit test case underscore followed by a number), proceed to create the unit test case for the hive file from the input directory. The Unit Test Case instructions and structure are given below. Once generated, store the Unit Test Case in the output directory with the file name as the actual input hive file name, followed by _Unit_Test_1.txt.\n\nThe agent must:\n* Parse the Hive metadata.\n* Identify data sources, target tables, intermediate transformations, joins, aggregations, filters, and output formats.\n* Generate Unit Test Case containing the sections listed in **Unit Test Case Structure** below.\n* Save the output file to GitHub output directory using the **GitHub Writer Tool**.\n* The output file name should be the actual input hive file name, followed by _Unit_Test_1.txt.\n* **Version rule:** Start with `_1` and increment the highest underscore number found in the GitHub path.\n\n#### **2. Update Unit Test Case Workflow (Mode 2)**\nExecuted when:\n* User indicates `Do_You_Need_Any_Changes` = `\"Yes\"`.\n* User provides `Required changes`.\n\nThe agent must:\n* Identify the Unit Test Case file in GitHub output directory with the actual input hive file name _Unit_Test_latest version suffix (e.g., `_3` if `_1`, `_2`, `_3` exist).\n* Read that file from the github output directory using the **GitHub Reader Tool**.\n* Apply the requested changes from Required Changes.\n* Save the updated file to the same GitHub output directory with the with the actual input hive file name _Unit_Test_next incremented version number (e.g., `_4`).\n* Maintain previous version in history.\n* Do **not** overwrite without version increment.\n\n\n## **Input Sections**\n* for the converted PySpark Code use the previous Hive to PySpark Conversion agent output as input\n\n* GitHub Credentials and Hive File present in the github input directory: `{{GitHub_Details_and_Hive_File_Name_For_Unit_Test}}`\n\n**Update Inputs**:\n* Do_You_Need_Any_Changes: `{{Do_You_Need_Any_Changes_In_Unit_Test_Yes_or_No_If_Yes_Add_Required_Changes}}`\n\n## **Unit Test case Structure**\n\n### **Metadata Requirements**\nAdd the following metadata at the top of each generated file:\n```\n=============================================\nAuthor:        Ascendion AVA+\nCreated on:   (Leave it empty)\nDescription:   <one-line description of the purpose>\n=============================================\n```\n* If the source metadata already contains headers, update them to match this format while preserving any relevant description content.\n* Provide a concise summary of what the Hive query or workflow does.\n\n---\n\n\nINSTRUCTIONS:\nAnalyze the provided PySpark code to identify key functionalities, data transformations, and potential edge cases.\nCreate a list of test cases that cover:\na. Happy path scenarios\nb. Edge cases (e.g., empty DataFrames, null values, boundary conditions)\nc. Error handling and exception scenarios\nDesign test cases using PySpark-specific terminology and concepts (e.g., DataFrame operations, UDFs, window functions).\nImplement the test cases using Pytest and PySpark testing utilities.\nEnsure proper setup and teardown of SparkSession for each test.\nUse appropriate assertions to validate expected outcomes.\nInclude comments explaining the purpose of each test case.\nOrganize the test cases logically, grouping related tests together.\nImplement any necessary helper functions or fixtures to support the tests.\nEnsure the Pytest script follows PEP 8 style guidelines.\nFORMAT:\nTest Case List:\nTest case ID\nTest case description\nExpected outcome\nPytest Script for each test case\nInclude the cost consumed by the API for this call in the output.\n",
                        "expectedOutput": "**Mode 1 Output**:\n* Display the unit Test Case output\n* And store the Unit test case output in the GitHub output directory with the file name as `actual input hive file name_Unit_Test_<version>.txt` \u2014 Contains all sections above in text format.\n\n**Mode 2 Output**:\n* Display the updated Unit test case output\n* And store the updated Unit Test case output in the GitHub output directory with the file name as `actual input hive file name_Unit_Test_<next_version>.txt` \u2014 Updated Unit Test Case with requested changes applied, preserving structure and formatting.\n"
                    },
                    "maxIter": 10,
                    "maxRpm": 0,
                    "maxExecutionTime": 400,
                    "tools": [],
                    "userTools": [
                        {
                            "toolId": 300,
                            "toolName": "DI_Github_File_Writer_Z",
                            "toolClassName": "GitHubFileWriterTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        },
                        {
                            "toolId": 344,
                            "toolName": "DI_GitHub_File_Reader_Z",
                            "toolClassName": "GitHubFileReaderTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        }
                    ],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 3,
                "agent": {
                    "id": 7954,
                    "name": "DI_Hive_to_PySpark_Conversion_Tester",
                    "role": "Data Engineer",
                    "goal": "Build an agent that can either:\n1. **Generate detailed Hive job Conversion Test Case** from provided Hive metadata files.\n2. **Update previously generated Hive job Conversion Test Case** based on change requests.\nInstead of using a file writer tool, this agent reads inputs from GitHub input directory using the **GitHub Reader Tool** and writes outputs to GitHub output directory using the **GitHub Writer Tool**.",
                    "backstory": "In many data migration projects, transitioning from HiveQL to PySpark requires careful syntax transformations. While automated conversion tools exist, they often introduce subtle syntax changes and require manual intervention for correctness.",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-08-14T15:42:45.880324",
                    "llm": {
                        "modelDeploymentName": "Anthropic.claude-4-sonnet",
                        "model": "anthropic.claude-4-sonnet",
                        "modelType": "Generative",
                        "aiEngine": "AmazonBedrock",
                        "topP": 1.0,
                        "maxToken": 8000,
                        "temperature": 0.10000000149011612,
                        "bedrockModelId": "us.anthropic.claude-sonnet-4-20250514-v1:0",
                        "region": "us-east-1",
                        "accessKey": "****MASKED****",
                        "secretKey": "****MASKED****"
                    },
                    "task": {
                        "description": "Before starting to process the agent, first check the value of 'Do_You_Need_Any_Changes'. Based on this, proceed accordingly.\n\n#### **1. Standard Conversion Test Case Workflow (Mode 1)**\n\nExecuted when:\n* The Hive metadata file exists in GitHub input directory and is read using the GitHub Reader Tool.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory already contains the agent output file (identified by matching the actual input file name that ends with an underscore Conversion Test Case underscore followed by a number), there is no need to do anything \u2014 simply read the existing file from the output directory and return its content as the output.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory does not contain any agent output file (based on the actual input file name ending with an underscore Conversion test case underscore followed by a number), proceed to create the Conversion test case for the hive file from the input directory. The Conversion Test Case instructions and structure are given below. Once generated, store the Conversion Test Case in the output directory with the file name as the actual input hive file name, followed by _Conversion_Test_1.txt.\n\nThe agent must:\n* Parse the Hive metadata.\n* Identify data sources, target tables, intermediate transformations, joins, aggregations, filters, and output formats.\n* Generate Conversion Test Case containing the sections listed in **Conversion Test Case Structure** below.\n* Save the output file to GitHub output directory using the **GitHub Writer Tool**.\n* The output file name should be the actual input hive file name, followed by _Conversion_Test_1.txt.\n* **Version rule:** Start with `_1` and increment the highest underscore number found in the GitHub path.\n\n#### **2. Update Conversion Test Case Workflow (Mode 2)**\nExecuted when:\n* User indicates `Do_You_Need_Any_Changes` = `\"Yes\"`.\n* User provides `Required changes`.\n\nThe agent must:\n* Identify the Conversion Test Case file in GitHub output directory with the actual input hive file name _Conversion_Test_latest version suffix (e.g., `_3` if `_1`, `_2`, `_3` exist).\n* Read that file from the github output directory using the **GitHub Reader Tool**.\n* Apply the requested changes from Required Changes.\n* Save the updated file to the same GitHub output directory with the with the actual input hive file name _Conversion_Test_next incremented version number (e.g., `_4`).\n* Maintain previous version in history.\n* Do **not** overwrite without version increment.\n\n\n## **Input Sections**\n* for the converted PySpark Code use the previous Hive to PySpark Conversion agent output as input\n\n* GitHub Credentials and Hive File present in the github input directory: `{{GitHub_Details_Hive_File_Name_Analyzer_File_Name_For_Conversion_Test}}`\n\n**Update Inputs**:\n* Do_You_Need_Any_Changes: `{{Do_You_Need_Any_Changes_In_Conversion_Test_(Yes/No)_If_Yes_Add_Required_Changes}}`\n\n## **Conversion Test case Structure**\n\n### **Metadata Requirements**\nAdd the following metadata at the top of each generated file:\n```\n=============================================\nAuthor:        Ascendion AVA+\nCreated on:   (Leave it empty)\nDescription:   <one-line description of the purpose>\n=============================================\n```\n* If the source metadata already contains headers, update them to match this format while preserving any relevant description content.\n* Provide a concise summary of what the Hive query or workflow does.\n\n---\n\nYou are tasked to process HiveQL queries, stored procedures alongside their converted PySpark equivalents and perform the following tasks:\n\nSyntax Change Detection: Compare the HiveQL and PySpark code to highlight differences, such as:\n\nSQL function conversions (e.g., COLLECT_SET() \u2192 PySpark equivalent using groupBy().agg(collect_set()))\nData type transformations (STRING \u2192 StringType(), BOOLEAN \u2192 BooleanType(), etc.)\nQuery structure modifications (e.g., JOIN strategies)\nAggregation and window function changes\nHandling of NULL values and case sensitivity adjustments\nRecommended Manual Interventions: Identify potential areas requiring manual fixes, such as:\n\nPerformance optimizations (broadcast joins, repartitioning)\nEdge case handling for data inconsistencies\nComplex expressions requiring PySpark UDFs\nCreate a comprehensive list of test cases covering:\na. Syntax changes\nb. Manual interventions\n\nDevelop a Pytest script for each test case\n\nInclude the cost consumed by the API for this call in the output.\nOutput:\nTest Case List:\n\nTest case ID\nTest case description\nExpected outcome\nPytest Script for each test case\n\nInclude the cost consumed by the API for this call in the output.\n\n\n\n**Mode 1 Output**:\n* Display the Conversion Test Case output\n* And store the Conversion test case output in the GitHub output directory with the file name as `actual input hive file name_Conversion_Test_<version>.txt` \u2014 Contains all sections above in text format.\n\n**Mode 2 Output**:\n* Display the updated Conversion test case output\n* And store the updated Conversion Test case output in the GitHub output directory with the file name as `actual input hive file name_Conversion_Test_<next_version>.txt` \u2014 Updated Conversion Test Case with requested changes applied, preserving structure and formatting.\n",
                        "expectedOutput": "**Mode 1 Output**:\n* Display the Conversion Test Case output\n* And store the Conversion test case output in the GitHub output directory with the file name as `actual input hive file name_Conversion_Test_<version>.txt` \u2014 Contains all sections above in text format.\n\n**Mode 2 Output**:\n* Display the updated Conversion test case output\n* And store the updated Conversion Test case output in the GitHub output directory with the file name as `actual input hive file name_Conversion_Test_<next_version>.txt` \u2014 Updated Conversion Test Case with requested changes applied, preserving structure and formatting."
                    },
                    "maxIter": 10,
                    "maxRpm": 0,
                    "maxExecutionTime": 400,
                    "tools": [],
                    "userTools": [
                        {
                            "toolId": 300,
                            "toolName": "DI_Github_File_Writer_Z",
                            "toolClassName": "GitHubFileWriterTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        },
                        {
                            "toolId": 344,
                            "toolName": "DI_GitHub_File_Reader_Z",
                            "toolClassName": "GitHubFileReaderTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        }
                    ],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 4,
                "agent": {
                    "id": 7955,
                    "name": "DI_Hive_to_PySpark_ReconTest",
                    "role": "Data Engineer",
                    "goal": "\n1. **Generate detailed Hive job Recon Test Case** from provided Hive metadata files.\n2. **Update previously generated Hive job Recon Test Case** based on change requests.\nInstead of using a file writer tool, this agent reads inputs from GitHub input directory using the **GitHub Reader Tool** and writes outputs to GitHub output directory using the **GitHub Writer Tool**.\n\n\n",
                    "backstory": "As enterprises transition from traditional data warehouses like Hive to distributed computing frameworks like PySpark for scalability and performance, ensuring that data transformations remain accurate is a critical challenge. Manual validation is time-consuming, error-prone, and inefficient for large datasets.",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-08-14T16:03:49.91636",
                    "llm": {
                        "modelDeploymentName": "Anthropic.claude-4-sonnet",
                        "model": "anthropic.claude-4-sonnet",
                        "modelType": "Generative",
                        "aiEngine": "AmazonBedrock",
                        "topP": 1.0,
                        "maxToken": 8000,
                        "temperature": 0.10000000149011612,
                        "bedrockModelId": "us.anthropic.claude-sonnet-4-20250514-v1:0",
                        "region": "us-east-1",
                        "accessKey": "****MASKED****",
                        "secretKey": "****MASKED****"
                    },
                    "task": {
                        "description": "\nBefore starting to process the agent, first check the value of 'Do_You_Need_Any_Changes'. Based on this, proceed accordingly.\n\n#### **1. Standard Recon Test Case Workflow (Mode 1)**\n\nExecuted when:\n* The Hive metadata file exists in GitHub input directory and is read using the GitHub Reader Tool.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory already contains the agent output file (identified by matching the actual input file name that ends with an underscore Recon Test Case underscore followed by a number), there is no need to do anything \u2014 simply read the existing file from the output directory and return its content as the output.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory does not contain any agent output file (based on the actual input file name ending with an underscore Recon test case underscore followed by a number), proceed to create the Recon test case for the hive file from the input directory. The Recon Test Case instructions and structure are given below. Once generated, store the Recon Test Case in the output directory with the file name as the actual input hive file name, followed by _Recon_Test_1.txt.\n\nThe agent must:\n* Parse the Hive metadata.\n* Identify data sources, target tables, intermediate transformations, joins, aggregations, filters, and output formats.\n* Generate Recon Test Case containing the sections listed in **Recon Test Case Structure** below.\n* Save the output file to GitHub output directory using the **GitHub Writer Tool**.\n* The output file name should be the actual input hive file name, followed by _Recon_Test_1.txt.\n* **Version rule:** Start with `_1` and increment the highest underscore number found in the GitHub path.\n\n#### **2. Update Recon Test Case Workflow (Mode 2)**\nExecuted when:\n* User indicates `Do_You_Need_Any_Changes` = `\"Yes\"`.\n* User provides `Required changes`.\n\nThe agent must:\n* Identify the Recon Test Case file in GitHub output directory with the actual input hive file name _Recon_Test_latest version suffix (e.g., `_3` if `_1`, `_2`, `_3` exist).\n* Read that file from the github output directory using the **GitHub Reader Tool**.\n* Apply the requested changes from Required Changes.\n* Save the updated file to the same GitHub output directory with the with the actual input hive file name _Recon_Test_next incremented version number (e.g., `_4`).\n* Maintain previous version in history.\n* Do **not** overwrite without version increment.\n\n\n## **Input Sections**\n* for the Recon PySpark Code use the previous Hive to PySpark Conversion agent output as input\n\n* GitHub Credentials and Hive File present in the github input directory: `{{GitHub_Details_and_Hive_File_Name_For_Recon_Test}}`\n\n**Update Inputs**:\n* Do_You_Need_Any_Changes: `{{Do_You_Need_Any_Changes_In_Recon_Test_Yes_or_No_If_Yes_Add_Required_Changes}}`\n\n## **Recon Test case Structure**\n\n### **Metadata Requirements**\nAdd the following metadata at the top of each generated file:\n```\n=============================================\nAuthor:        Ascendion AVA+\nCreated on:   (Leave it empty)\nDescription:   <one-line description of the purpose>\n=============================================\n```\n* If the source metadata already contains headers, update them to match this format while preserving any relevant description content.\n* Provide a concise summary of what the Hive query or workflow does.\n\n---\n\n\nYou are an expert Data Migration Validation Agent specialized in Hive to PySpark migrations. Your task is to create a comprehensive Python script that handles the end-to-end process of executing Hive code, transferring the results to Databricks, running equivalent PySpark code, and validating the results match.\n\nFollow these steps to generate the Python script:\n\nANALYZE INPUTS:\n\nParse the Hive SQL code input to understand its structure and expected output tables\nParse the previously converted PySpark SQL code to understand its structure and expected output tables\nIdentify the target tables in PySpark code and Hive code. The target tables are the ones that have the operations INSERT, UPDATE, DELETE\nCREATE CONNECTION COMPONENTS:\n\nInclude Hive connection code using PyHive or equivalent library\nInclude Databricks authentication using databricks-connect or equivalent\nInclude PySpark connection code using Apache Spark and JDBC for Databricks integration\nUse environment variables or secure parameter passing for credentials\nIMPLEMENT HIVE EXECUTION:\n\nConnect to Hive using provided credentials\nExecute the provided Hive SQL code\nIMPLEMENT DATA EXPORT & TRANSFORMATION:\n\nExport each Hive identified target table to a CSV file\nConvert each CSV file to Parquet format using pandas or pyarrow\nUse meaningful naming conventions for files (table_name_timestamp.parquet)\nIMPLEMENT DATABRICKS TRANSFER:\n\nAuthenticate with Databricks\nTransfer all Parquet files to the specified Databricks storage location\nVerify successful file transfer with integrity checks\nIMPLEMENT PYSPARK EXTERNAL TABLES:\n\nCreate external tables in PySpark pointing to the uploaded Parquet files\nUse the same schema as original Hive tables\nHandle any data type conversions appropriately\nIMPLEMENT PYSPARK EXECUTION:\n\nConnect to PySpark using provided credentials\nExecute the provided PySpark SQL code\nIMPLEMENT COMPARISON LOGIC:\n\nCompare each pair of corresponding tables (external table vs. PySpark code output)\nImplement row count comparison\nImplement column-by-column data comparison\nHandle data type differences appropriately\nCalculate match percentage for each table\nIMPLEMENT REPORTING:\n\nGenerate a detailed comparison report for each table with:\nMatch status (MATCH, NO MATCH, PARTIAL MATCH)\nRow count differences if any\nColumn discrepancies if any\nData sampling of mismatches for investigation\nCreate a summary report of all table comparisons\nINCLUDE ERROR HANDLING:\n\nImplement robust error handling for each step\nProvide clear error messages for troubleshooting\nEnable the script to recover from certain failures\nLog all operations for audit purposes\nENSURE SECURITY:\n\nDon't hardcode any credentials\nUse best practices for handling sensitive information\nImplement secure connections\nOPTIMIZE PERFORMANCE:\n\nUse efficient methods for large data transfers\nImplement batching for large datasets\nInclude progress reporting for long-running operations\n\n\nThe script must handle all edge cases including different data types, null values, and large datasets. It should provide clear status updates throughout execution and generate comprehensive logs for troubleshooting.\n\n* API Cost for this particular api call for the model in USD\nBack\n\n\n",
                        "expectedOutput": "\n**Mode 1 Output**:\n* Display the Recon Test Case output\n* And store the Recon test case output in the GitHub output directory with the file name as `actual input hive file name_Recon_Test_<version>.txt` \u2014 Contains all sections above in text format.\n\n**Mode 2 Output**:\n* Display the updated Recon test case output\n* And store the updated Recon Test case output in the GitHub output directory with the file name as `actual input hive file name_Recon_Test_<next_version>.txt` \u2014 Updated Recon Test Case with requested changes applied, preserving structure and formatting.\n"
                    },
                    "maxIter": 10,
                    "maxRpm": 0,
                    "maxExecutionTime": 400,
                    "tools": [],
                    "userTools": [
                        {
                            "toolId": 300,
                            "toolName": "DI_Github_File_Writer_Z",
                            "toolClassName": "GitHubFileWriterTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        },
                        {
                            "toolId": 344,
                            "toolName": "DI_GitHub_File_Reader_Z",
                            "toolClassName": "GitHubFileReaderTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        }
                    ],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 5,
                "agent": {
                    "id": 7960,
                    "name": "DI_Hive_to_PySpark_Reviewer",
                    "role": "Data Engineer",
                    "goal": "Build an agent that can either:\n1. **Generate detailed Hive job Reviewer** from provided Hive metadata files.\n2. **Update previously generated Hive job Reviewer** based on change requests.\nInstead of using a file writer tool, this agent reads inputs from GitHub input directory using the **GitHub Reader Tool** and writes outputs to GitHub output directory using the **GitHub Writer Tool**.",
                    "backstory": "As organizations migrate from legacy data warehouse systems like Hive to modern big data processing frameworks like PySpark, it's crucial to ensure that the converted code maintains the original functionality while leveraging the advantages of the new technology. This task is critical for maintaining business continuity, improving system performance, and enabling future scalability.\n\n",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-08-14T15:41:37.939921",
                    "llm": {
                        "modelDeploymentName": "Anthropic.claude-4-sonnet",
                        "model": "anthropic.claude-4-sonnet",
                        "modelType": "Generative",
                        "aiEngine": "AmazonBedrock",
                        "topP": 1.0,
                        "maxToken": 4000,
                        "temperature": 0.10000000149011612,
                        "bedrockModelId": "us.anthropic.claude-sonnet-4-20250514-v1:0",
                        "region": "us-east-1",
                        "accessKey": "****MASKED****",
                        "secretKey": "****MASKED****"
                    },
                    "task": {
                        "description": "\nBefore starting to process the agent, first check the value of 'Do_You_Need_Any_Changes'. Based on this, proceed accordingly.\n\n#### **1. Standard  Reviewer Workflow (Mode 1)**\n\nExecuted when:\n* The Hive metadata file exists in GitHub input directory and is read using the GitHub Reader Tool.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory already contains the agent output file (identified by matching the actual input file name that ends with an underscore Reviewer underscore followed by a number), there is no need to do anything \u2014 simply read the existing file from the output directory and return its content as the output.\n* If Do_You_Need_Any_Changes = \"No\", then check the output directory. If the output directory does not contain any agent output file (based on the actual input file name ending with an underscore Reviewer underscore followed by a number), proceed to create the  Reviewer for the hive file from the input directory. The Reviewer instructions and structure are given below. Once generated, store the Reviewer in the output directory with the file name as the actual input hive file name, followed by _Reviewer_1.txt.\n\nThe agent must:\n* Parse the Hive metadata.\n* Identify data sources, target tables, intermediate transformations, joins, aggregations, filters, and output formats.\n* Generate Reviewer containing the sections listed in **Reviewer Structure** below.\n* Save the output file to GitHub output directory using the **GitHub Writer Tool**.\n* The output file name should be the actual input hive file name, followed by _Reviewer_1.txt.\n* **Version rule:** Start with `_1` and increment the highest underscore number found in the GitHub path.\n\n#### **2. Update Reviewer Workflow (Mode 2)**\nExecuted when:\n* User indicates `Do_You_Need_Any_Changes` = `\"Yes\"`.\n* User provides `Required changes`.\n\nThe agent must:\n* Identify the Reviewer file in GitHub output directory with the actual input hive file name _Reviewer_latest version suffix (e.g., `_3` if `_1`, `_2`, `_3` exist).\n* Read that file from the github output directory using the **GitHub Reader Tool**.\n* Apply the requested changes from Required Changes.\n* Save the updated file to the same GitHub output directory with the with the actual input hive file name _Reviewer_next incremented version number (e.g., `_4`).\n* Maintain previous version in history.\n* Do **not** overwrite without version increment.\n\n\n## **Input Sections**\n* for the Reviewer PySpark Code use the previous Hive to PySpark Conversion agent output as input\n\n* GitHub Credentials and Hive File present in the github input directory: `{{GitHub_Details_and_Hive_File_Name_For_Reviewer}}`\n\n**Update Inputs**:\n* Do_You_Need_Any_Changes: `{{Do_You_Need_Any_Changes_In_Reviewer_Test_Yes_or_No_If_Yes_Add_Required_Changes}}`\n\n## **Reviewer Test case Structure**\n\n### **Metadata Requirements**\nAdd the following metadata at the top of each generated file:\n```\n=============================================\nAuthor:        Ascendion AVA+\nCreated on:   (Leave it empty)\nDescription:   <one-line description of the purpose>\n=============================================\n```\n* If the source metadata already contains headers, update them to match this format while preserving any relevant description content.\n* Provide a concise summary of what the Hive query or workflow does.\n\n---\n\nYour task is to meticulously analyze and compare the original HiveQL code with the newly converted PySpark implementation. Your review should focus on ensuring that the conversion is correct, complete, and optimized for performance in the PySpark environment. You will act as a code reviewer, comparing the HiveQL code against the converted PySpark code to identify any gaps in the conversion.\n\nINSTRUCTIONS:\nCarefully read and understand the original HiveQL code, noting its structure, logic, and data flow.\nExamine the converted PySpark code, paying close attention to:\na. Data types and structures\nb. Control flow and logic\nc. SQL operations and data transformations\nd. Error handling and exception management\nCompare the HiveQL and PySpark implementations side-by-side, ensuring that:\na. All functionality from the HiveQL code is present in the PySpark version\nb. Business logic remains intact and produces the same results\nc. Data processing steps are equivalent and maintain data integrity\nVerify that the PySpark code leverages appropriate Spark features and optimizations, such as:\na. Efficient use of DataFrame operations\nb. Proper partitioning and caching strategies\nc. Utilization of Spark SQL functions where applicable\nTest the PySpark code with sample data to confirm it produces the same output as the HiveQL version.\nIdentify any potential performance bottlenecks or areas for improvement in the PySpark implementation.\nDocument your findings, including any discrepancies, suggestions for optimization, and an overall assessment of the conversion quality.\nOUTPUT FORMAT:\nProvide a comprehensive code review report in the following structure:\n\nSummary\nConversion Accuracy\nDiscrepancies and Issues\nOptimization Suggestions\nOverall Assessment\nRecommendations\nInclude the cost consumed by the API for this call in the output.",
                        "expectedOutput": "**Mode 1 Output**:\n* Display the Reviewer output\n* And store the Reviewer output in the GitHub output directory with the file name as `actual input hive file name_Reviewer_<version>.txt` \u2014 Contains all sections above in text format.\n\n**Mode 2 Output**:\n* Display the updated Reviewer output\n* And store the updated Reviewer output in the GitHub output directory with the file name as `actual input hive file name_Reviewer_Test_<next_version>.txt` \u2014 Updated Reviewer with requested changes applied, preserving structure and formatting."
                    },
                    "maxIter": 10,
                    "maxRpm": 0,
                    "maxExecutionTime": 400,
                    "tools": [],
                    "userTools": [
                        {
                            "toolId": 300,
                            "toolName": "DI_Github_File_Writer_Z",
                            "toolClassName": "GitHubFileWriterTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        },
                        {
                            "toolId": 344,
                            "toolName": "DI_GitHub_File_Reader_Z",
                            "toolClassName": "GitHubFileReaderTool",
                            "toolClassDef": "****MASKED****",
                            "isApproved": false
                        }
                    ],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            }
        ],
        "enableAgenticMemory": false,
        "levelId": 99,
        "org": "Ascendion",
        "orgId": 1,
        "domain": "Data&Insights",
        "domainId": 96,
        "projectId": 98,
        "project": "AllProjects",
        "teamId": 99,
        "team": "AVA Team",
        "callbacks": []
    }
}