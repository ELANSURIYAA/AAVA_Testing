{
    "pipeline": {
        "pipelineId": 828,
        "name": "Fabric Aggregated Data Engineer Gold Layer",
        "description": "Fabric Fact Data Engineer Gold Layer",
        "createdAt": "2025-03-27T04:50:56.999+00:00",
        "pipeLineAgents": [
            {
                "serial": 1,
                "agent": {
                    "id": 1106,
                    "name": "Fabric Gold Aggregated DE Pipeline",
                    "role": "Data modeler",
                    "goal": "To efficiently move Silver Layer data into Gold Layer Aggregate tables within a Microsoft Fabric environment, ensuring data quality and optimizing performance.",
                    "backstory": "This task is crucial for enhancing data analytics capabilities, improving query performance, and enabling efficient business intelligence reporting. By creating precomputed aggregates, we can significantly reduce processing time for complex queries and provide faster insights to stakeholders.",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-06-25T11:39:50.610951",
                    "llm": {
                        "modelDeploymentName": "gpt-4.1",
                        "model": "gpt-4",
                        "modelType": "Generative",
                        "aiEngine": "AzureOpenAI",
                        "topP": 0.949999988079071,
                        "maxToken": 8000,
                        "temperature": 0.30000001192092896,
                        "llmDeploymentName": "gpt-4.1",
                        "apiKey": "****MASKED****",
                        "azureEndpoint": "https://avaplus-cognitive-account-int.openai.azure.com/",
                        "llmApiVersion": "2025-01-01-preview"
                    },
                    "task": {
                        "description": "INSTRUCTIONS :\n1. Extract Data from Silver Layer:\n* Read aggregable transactional data from Silver Layer.\n* Ensure table names are in lowercase.\n2. Apply Business Transformations for Aggregates:\n3. Precompute summary statistics like:\n* Daily, weekly, monthly totals (e.g., total sales, total revenue).\n* Average order values, customer lifetime value.\n* Rolling aggregations (e.g., 7-day moving average, year-to-date totals).\n* Group data at appropriate levels (e.g., by customer, product, region, time).\n4. Error Record in Dimension Table :\n * ensure the error data table is also available in the Gold Dimension Table\n5. Audit Logging for Aggregations:\n* Capture processing timestamps, execution status, and errors.\n6. Optimize Performance for Aggregates:\n* Partition on time-based fields (e.g., month, year).\n* Store in Delta format with efficient compression.\n* Index aggregated key fields to speed up query performance.\n7. Verify Gold Layer Compatibility:\n* Validate aggregate table structures against Gold Layer DDL.\n* Ensure transformations follow Microsoft Fabric best practices.\n\nInput:\n* For Credentials, Source Silver layer data structure, Target Physical model DDL script for Gold layer and Fabric Model Data Mapping Gold Layer use this file : ```%1$s```\n\nOutput :\nENSURE THE SAMPLE OUTPUT SHOULD BE IN THIS FORMAT :\n```\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\nfrom pyspark.sql.window import Window\nfrom pyspark.sql.functions import col, datediff, avg, count, when, date_add, sum\n\ndef create_spark_session():\n    \"\"\"Create Spark session with Delta Lake support and configure paths\"\"\"\n    spark = SparkSession.builder \\\n        .appName(\"Silver to Bronze Data Processing\") \\\n        .config(\"spark.databricks.delta.schema.autoMerge.enabled\", \"true\") \\\n        .getOrCreate()\n    return spark\n\nsilver_path = #Take and use the silver layer path from the given input file \ngold_path = #Take and use the gold layer path from the given input file \n\ndef read_silver_table(spark, table_name):\n    \"\"\"Read table from Silver layer\"\"\"\n    return spark.read.format(\"delta\").load(f\"{silver_path}{table_name}\")\n\ndef write_gold_table(df, table_name, mode=\"overwrite\"):\n    \"\"\"Write table to Gold layer\"\"\"\n    df.write.format(\"delta\").mode(mode).save(f\"{gold_path}{table_name}\")\n\ndef transform_tablename_aggregated(spark): # replace with proper function name \n    \"\"\"Transform Products dimension table\"\"\"\n    # Read from Silver layer\n    tablename1_df = read_silver_table(spark, #silver layer table name 1)\n    tablename2_df = read_silver_table(spark, #silver layer table name 2) etc..\n    \n    variable_for_table_name #replace with proper variable = # add a transformation logic with necessary functions eg. join, agg, groupby etc...\n    \n    # Write to Gold layer\n    write_gold_table(#gold_layer_table_name, #variable_for_table_name) #replace with actual variable and actual gold layer table name\n\n# similarly create other functions for all the required transformation logic in the above mentioned format\n\ndef main():\n    \"\"\"Main execution function\"\"\"\n    spark = create_spark_session()\n    \n    try:\n\n        # Transform aggregated tables\n        transform_tablename1_aggregated(spark) # replace with proper function name 1\n        transform_tablename2_aggregated(spark) # replace with proper function name 2 \n        etc..\n\n    finally:\n        spark.stop()\n\nif __name__ == \"__main__\":\n    main() \n```",
                        "expectedOutput": "1. PySpark script for processing data into the Aggregate Table.\n2. Error-handling mechanism for invalid records.\n- audit Logs for validation or transformation logic success or failures.\n- Error data table stored in gold layer aggregate table.\n- API cost consumed displayed explicitly after the PySpark code"
                    },
                    "maxIter": 0,
                    "maxRpm": 0,
                    "maxExecutionTime": 0,
                    "tools": [],
                    "userTools": [],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            },
            {
                "serial": 2,
                "agent": {
                    "id": 814,
                    "name": "Fabric Pyspark Unit Test Case",
                    "role": "Data Engineer",
                    "goal": "Ensure the reliability and performance of PySpark applications in Microsoft Fabric by generating comprehensive unit test cases and a corresponding Pytest script. This will validate key functionalities, edge cases, and error handling in the provided PySpark code.",
                    "backstory": "Effective unit testing is essential for maintaining high-quality data pipelines in Microsoft Fabric. By implementing robust test cases, we can catch potential issues early in the development cycle, enhance maintainability, and prevent production failures. This testing framework will help validate data transformations and processing logic, ensuring that PySpark code runs efficiently in Fabric\u2019s Spark environment.",
                    "verbose": true,
                    "allowDelegation": true,
                    "updatedAt": "2025-06-25T09:19:08.530764",
                    "llm": {
                        "modelDeploymentName": "gpt-4.1",
                        "model": "gpt-4",
                        "modelType": "Generative",
                        "aiEngine": "AzureOpenAI",
                        "topP": 0.949999988079071,
                        "maxToken": 8000,
                        "temperature": 0.30000001192092896,
                        "llmDeploymentName": "gpt-4.1",
                        "apiKey": "****MASKED****",
                        "azureEndpoint": "https://avaplus-cognitive-account-int.openai.azure.com/",
                        "llmApiVersion": "2025-01-01-preview"
                    },
                    "task": {
                        "description": "You are tasked with creating unit test cases and a Pytest script for the given PySpark code that runs in Microsoft Fabric. Your expertise in PySpark testing methodologies, best practices, and Fabric-specific optimizations will be crucial in ensuring comprehensive test coverage.\n\nInstructions:\n1. Analyze the provided PySpark code to identify:\n* Key data transformations\n* Edge cases (e.g., empty DataFrames, null values, boundary conditions)\n* Error handling scenarios\n2. Design test cases covering:\n* Happy path scenarios\n* Edge cases (handling missing/null values, schema mismatches, etc.)\n* Exception scenarios (invalid data types, incorrect transformations)\n3. Use Microsoft Fabric-compatible PySpark testing techniques, including:\n* SparkSession setup and teardown in Fabric\u2019s distributed environment\n* Mocking external data sources within Fabric\u2019s Lakehouse\n* Performance testing in Fabric\u2019s Spark pools\n* Implement test cases using Pytest and Fabric-compatible PySpark testing utilities.\n* Ensure Fabric SparkSession is properly initialized and closed in test setup/teardown.\n* Use assertions to validate expected DataFrame outputs.\n* Follow PEP 8 coding style and ensure test scripts are well-commented.\n* Group related test cases into logical sections for maintainability.\n* Implement helper functions or fixtures to support Fabric-based Spark testing.\n\nGuideline:\n*Additionally, calculate and include the cost consumed by the API for this call in the output, explicitly mentioning the cost in USD. Don't consider the API cost as input and retrieve the cost of this API. \n*Ensure the cost consumed by the API is reported as a precise floating-point value, without rounding or truncation, until the first non-zero digit appears.\n*If the API returns the same cost across multiple calls, fetch real-time cost data or validate the calculation method.\n*Ensure that cost computation considers different agents and their unique execution parameters.\n*Mention the API Cost after the PySpark code ends.\n\ninput :\nUse the output of the previous agents PySpark code as input",
                        "expectedOutput": "1. Test Case List\nEach test case should include:\n*Test Case ID\n*Test Case Description\n*Expected Outcome\n2. Pytest Script\n*Fabric-optimized Pytest script with unit test cases for the PySpark code.\n*Ensures compatibility with Microsoft Fabric\u2019s Spark execution environment.\n\n* apiCost: float  // Cost consumed by the API for this call (in USD)\n*Ensure the cost consumed by the API is mentioned with inclusive of all decimal value"
                    },
                    "maxIter": 0,
                    "maxRpm": 0,
                    "maxExecutionTime": 0,
                    "tools": [],
                    "userTools": [],
                    "allowCodeExecution": false,
                    "isSafeCodeExecution": true
                }
            }
        ],
        "enableAgenticMemory": false,
        "levelId": 4,
        "org": "Ascendion",
        "orgId": 1,
        "domain": "Platform Engineering",
        "domainId": 2,
        "projectId": 3,
        "project": "AVA",
        "teamId": 4,
        "team": "Digital Ascender",
        "callbacks": []
    }
}