{
  "data": {
    "message": "Workflow with agents retrieved successfully",
    "workFlowDetail": {
      "id": 2718,
      "name": "Fabric Aggregated Data Engineer Gold Layer",
      "description": "Fabric Fact Data Engineer Gold Layer",
      "createdBy": "default@ascendion.com",
      "modifiedBy": "default@ascendion.com",
      "approvedBy": "default@ascendion.com",
      "createdAt": "2025-11-05T11:12:53.439187",
      "modifiedAt": "2025-11-30T11:55:00.892060",
      "approvedAt": "2025-11-05T11:12:54.481350",
      "status": "APPROVED",
      "isDeleted": false,
      "parentId": -1,
      "workflowConfigs": {
        "managerLlm": [
          {}
        ],
        "enableAgenticMemory": false
      },
      "workflowAgents": [
        {
          "serial": 1,
          "agentId": 6394,
          "name": "Fabric Gold Aggregated DE Pipeline",
          "workflowId": 2718,
          "agentDetails": {
            "topP": 0.94,
            "maxRpm": null,
            "levelId": 99,
            "maxIter": null,
            "toolRef": [],
            "maxToken": "8000",
            "isVerbose": true,
            "temperature": 0.3,
            "allowDelegation": true,
            "maxExecutionTime": 90,
            "allowCodeExecution": false,
            "isSafeCodeExecution": true,
            "toolReferences": []
          },
          "modelDeploymentName": "gpt-4.1",
          "description": "INSTRUCTIONS :\n1. Extract Data from Silver Layer:\n* Read aggregable transactional data from Silver Layer.\n* Ensure table names are in lowercase.\n2. Apply Business Transformations for Aggregates:\n3. Precompute summary statistics like:\n* Daily, weekly, monthly totals (e.g., total sales, total revenue).\n* Average order values, customer lifetime value.\n* Rolling aggregations (e.g., 7-day moving average, year-to-date totals).\n* Group data at appropriate levels (e.g., by customer, product, region, time).\n4. Error Record in Dimension Table :\n * ensure the error data table is also available in the Gold Dimension Table\n5. Audit Logging for Aggregations:\n* Capture processing timestamps, execution status, and errors.\n6. Optimize Performance for Aggregates:\n* Partition on time-based fields (e.g., month, year).\n* Store in Delta format with efficient compression.\n* Index aggregated key fields to speed up query performance.\n7. Verify Gold Layer Compatibility:\n* Validate aggregate table structures against Gold Layer DDL.\n* Ensure transformations follow Microsoft Fabric best practices.\n\nInput:\n* For Credentials, Source Silver layer data structure, Target Physical model DDL script for Gold layer and Fabric Model Data Mapping Gold Layer use this file : ```%1$s```\n\nOutput :\nENSURE THE SAMPLE OUTPUT SHOULD BE IN THIS FORMAT :\n```\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\nfrom pyspark.sql.window import Window\nfrom pyspark.sql.functions import col, datediff, avg, count, when, date_add, sum\n\ndef create_spark_session():\n    \"\"\"Create Spark session with Delta Lake support and configure paths\"\"\"\n    spark = SparkSession.builder \\\n        .appName(\"Silver to Bronze Data Processing\") \\\n        .config(\"spark.databricks.delta.schema.autoMerge.enabled\", \"true\") \\\n        .getOrCreate()\n    return spark\n\nsilver_path = #Take and use the silver layer path from the given input file \ngold_path = #Take and use the gold layer path from the given input file \n\ndef read_silver_table(spark, table_name):\n    \"\"\"Read table from Silver layer\"\"\"\n    return spark.read.format(\"delta\").load(f\"{silver_path}{table_name}\")\n\ndef write_gold_table(df, table_name, mode=\"overwrite\"):\n    \"\"\"Write table to Gold layer\"\"\"\n    df.write.format(\"delta\").mode(mode).save(f\"{gold_path}{table_name}\")\n\ndef transform_tablename_aggregated(spark): # replace with proper function name \n    \"\"\"Transform Products dimension table\"\"\"\n    # Read from Silver layer\n    tablename1_df = read_silver_table(spark, #silver layer table name 1)\n    tablename2_df = read_silver_table(spark, #silver layer table name 2) etc..\n    \n    variable_for_table_name #replace with proper variable = # add a transformation logic with necessary functions eg. join, agg, groupby etc...\n    \n    # Write to Gold layer\n    write_gold_table(#gold_layer_table_name, #variable_for_table_name) #replace with actual variable and actual gold layer table name\n\n# similarly create other functions for all the required transformation logic in the above mentioned format\n\ndef main():\n    \"\"\"Main execution function\"\"\"\n    spark = create_spark_session()\n    \n    try:\n\n        # Transform aggregated tables\n        transform_tablename1_aggregated(spark) # replace with proper function name 1\n        transform_tablename2_aggregated(spark) # replace with proper function name 2 \n        etc..\n\n    finally:\n        spark.stop()\n\nif __name__ == \"__main__\":\n    main() \n```",
          "modelName": "model"
        },
        {
          "serial": 2,
          "agentId": 6442,
          "name": "Fabric Pyspark Unit Test Case",
          "workflowId": 2718,
          "agentDetails": {
            "topP": 0.94,
            "maxRpm": null,
            "levelId": 99,
            "maxIter": null,
            "toolRef": [],
            "maxToken": "8000",
            "isVerbose": true,
            "temperature": 0.3,
            "allowDelegation": true,
            "maxExecutionTime": 90,
            "allowCodeExecution": false,
            "isSafeCodeExecution": true,
            "toolReferences": []
          },
          "modelDeploymentName": "gpt-4.1",
          "description": "You are tasked with creating unit test cases and a Pytest script for the given PySpark code that runs in Microsoft Fabric. Your expertise in PySpark testing methodologies, best practices, and Fabric-specific optimizations will be crucial in ensuring comprehensive test coverage.\n\nInstructions:\n1. Analyze the provided PySpark code to identify:\n* Key data transformations\n* Edge cases (e.g., empty DataFrames, null values, boundary conditions)\n* Error handling scenarios\n2. Design test cases covering:\n* Happy path scenarios\n* Edge cases (handling missing/null values, schema mismatches, etc.)\n* Exception scenarios (invalid data types, incorrect transformations)\n3. Use Microsoft Fabric-compatible PySpark testing techniques, including:\n* SparkSession setup and teardown in Fabric\u2019s distributed environment\n* Mocking external data sources within Fabric\u2019s Lakehouse\n* Performance testing in Fabric\u2019s Spark pools\n* Implement test cases using Pytest and Fabric-compatible PySpark testing utilities.\n* Ensure Fabric SparkSession is properly initialized and closed in test setup/teardown.\n* Use assertions to validate expected DataFrame outputs.\n* Follow PEP 8 coding style and ensure test scripts are well-commented.\n* Group related test cases into logical sections for maintainability.\n* Implement helper functions or fixtures to support Fabric-based Spark testing.\n\nGuideline:\n*Additionally, calculate and include the cost consumed by the API for this call in the output, explicitly mentioning the cost in USD. Don't consider the API cost as input and retrieve the cost of this API. \n*Ensure the cost consumed by the API is reported as a precise floating-point value, without rounding or truncation, until the first non-zero digit appears.\n*If the API returns the same cost across multiple calls, fetch real-time cost data or validate the calculation method.\n*Ensure that cost computation considers different agents and their unique execution parameters.\n*Mention the API Cost after the PySpark code ends.\n\ninput :\nUse the output of the previous agents PySpark code as input",
          "modelName": "model"
        }
      ],
      "realmId": 1
    }
  },
  "status": "SUCCESS"
}