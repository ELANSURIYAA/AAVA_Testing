{
    "workFlowDetail": {
        "id": 8611,
        "name": "Charter KMPify"
    },
    "workflowAgents": [
        {
            "agentId": 17126,
            "name": "Charter Project Analyzer Agent ",
            "modelDeploymentName": "gpt-4.1",
            "description": "KMPifyAI is an intelligent automation agent that:\n\nAnalyzes a given Kotlin project folder.\n\nDetects platform-specific vs. shared code.\n\nAutomatically generates the KMP folder structure:\nsrc/\n\u2502       \u251c\u2500\u2500 commonMain/\n\u2502       \u251c\u2500\u2500 androidMain/\n\u2502       \u251c\u2500\u2500 iosMain/\n\u2502       \u251c\u2500\u2500 wasmjsMain/\n\u2502       \u251c\u2500\u2500 commonTest/\n\u2502       \u251c\u2500\u2500 iosTest/\n\u2502       \u2514\u2500\u2500 wasmjsTest/\n\nMoves or copies files into appropriate modules.\n\nGenerates expect and actual declarations where platform-specific APIs exist.\n\nUpdates Gradle build scripts to enable KMP support.\n\nProduces a detailed migration report with suggestions for manual refinements.\n\nKMPifyAI acts like a migration companion that helps developers adopt Kotlin Multiplatform with zero configuration headaches.\ngenerate all the files that kmp have generated from the project.\ni want all the file names in th structure when the kotlin project is converted to kmp project.\n\n#Note :\nThis agent output will serve as input to next agent.",
            "toolReferences": []
        },
        {
            "agentId": 17128,
            "name": "Charter Dependency Analyser",
            "modelDeploymentName": "gpt-4.1",
            "description": "- This agent acts as the Dependency Intelligence Layer of your KMP migration pipeline.\n- It takes the raw project structure output from Agent 1 (Project_Analyzer_Agent_Charter) and performs dependency discovery, compatibility evaluation, and migration mapping for Kotlin Multiplatform.\n- Essentially, it analyzes, validates, and transforms Gradle dependencies into a KMP-compatible dependency blueprint.\n- Charter_dependency_analyzer inspects and modernizes project dependencies for Kotlin Multiplatform readiness.\n- It identifies platform-bound libraries (Android-only, JVM-only) and maps or replaces them with multiplatform alternatives like Ktor, SQLDelight, Flow, etc.\n- It ensures that the output of the pipeline will build and run across Android, iOS, and Web (WasmJS) targets.\n\n## Inputs : \nProject ZIP Folder [Same input zip passed to Agent 1 (e.g., CoinTrend-main.zip)]\nOutput from Agent 1 (agent1_output)\n\n##Core Operations :\n| Phase                               | Description                                                                                                                                                      |\n| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **1. Dependency Extraction**        | Reads all Gradle build files (`build.gradle`, `build.gradle.kts`) from the input project. Extracts `implementation`, `api`, `kapt`, `annotationProcessor` lines. |\n| **2. Compatibility Classification** | Checks each dependency against a **KMP Compatibility Knowledge Base** (Retrofit, Room, LiveData \u2192 flagged).                                                      |\n| **3. Migration Mapping**            | Suggests or replaces incompatible dependencies with KMP-ready equivalents.                                                                                       |\n| **4. Version Normalization**        | Aligns versions across platforms for consistency (`ktor`, `coroutines`, `serialization`).                                                                        |\n| **5. Platform Hints**               | Identifies which dependencies are platform-specific (Android-only, JVM-only) and flags them for expect/actual abstraction.                                       |\n| **6. Output Generation**            | Produces a structured JSON or Markdown report, plus updated `build.gradle.kts` templates for KMP.                                                              |\n\n##Outputs:\n1. Dependency Migration Report\nDetailed summary of all project dependencies and their KMP compatibility status.\nExample:\nAnalyzing project...\nFound 14 dependencies\n 3 Android-only libraries detected\n 9 already KMP-compatible\n 2 mapped to KMP equivalents\n\n 2. Updated Dependency Plan\nBefore\t                                                                        After (KMP Compatible)\nimplementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\timplementation(\"io.ktor:ktor-client-core:3.0.0\")\nimplementation(\"androidx.room:room-runtime:2.6.1\")\timplementation(\"com.squareup.sqldelight:runtime:2.0.0\")\nimplementation(\"androidx.lifecycle:livedata-ktx:2.5.1\")\timplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0\")\n\n3. KMP-Compatible Gradle Template\nAuto-generated Gradle structure for shared module after dependency cleanup:\n\nshared/\n \u251c\u2500\u2500 build.gradle.kts\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 commonMain/\n \u2502   \u2502   \u251c\u2500\u2500 network/\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 KtorClient.kt\n \u2502   \u2502   \u251c\u2500\u2500 database/\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 SQLDelightSchema.kt\n \u2502   \u2502   \u251c\u2500\u2500 utils/\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 FlowExtensions.kt\n \u2502   \u2502   \u2514\u2500\u2500 viewmodel/\n \u2502   \u2502       \u2514\u2500\u2500 SharedViewModel.kt\n \u2502   \u251c\u2500\u2500 androidMain/\n \u2502   \u2502   \u2514\u2500\u2500 platform/AndroidPlatform.kt\n \u2502   \u251c\u2500\u2500 iosMain/\n \u2502   \u2502   \u2514\u2500\u2500 platform/IOSPlatform.kt\n \u2502   \u251c\u2500\u2500 wasmjsMain/\n \u2502   \u2502   \u2514\u2500\u2500 platform/WebPlatform.kt\n \u2514\u2500\u2500 gradle.properties\n\n4. Expect/Actual Templates\nFor any platform-specific APIs replaced, it auto-generates stubbed expect/actual code templates.\n\nExample:\n// commonMain\nexpect fun getPlatformInfo(): String\n\n// androidMain\nactual fun getPlatformInfo(): String = \"Running on Android\"\n\n// iosMain\nactual fun getPlatformInfo(): String = \"Running on iOS\"\n\n// wasmjsMain\nactual fun getPlatformInfo(): String = \"Running on Web (WasmJS)\"\n\n\n## Agent Intelligence Layer (Key Heuristics) :\n\nExample:\n| Category   | Detection Heuristic        | Replacement                                         |\n| ------------- | -------------------------------- | --------------------------------------------------- |\n| Networking    | Detects `retrofit2`, `okhttp3`   | Replace with `ktor-client-core`, `ktor-client-json` |\n| Database      | Detects `androidx.room`          | Replace with `SQLDelight`                           |\n| Reactive      | Detects `LiveData`, `RxJava`     | Replace with `kotlinx.coroutines.flow`              |\n| Serialization | Detects `Gson`, `Moshi`          | Replace with `kotlinx.serialization`                |\n| Platform APIs | Detects `android.*`, `java.io.*` | Moved to expect/actual implementations              |\n\n## Output Artifacts:\n\n| File / Report                      | Description                                                       |\n| ---------------------------------- | ----------------------------------------------------------------- |\n| `dependency_migration_report.json` | Structured report of all dependencies and their migration status. |\n| `build.gradle.kts.template`        | Updated Gradle file with new dependencies and source sets.        |\n| `expect_actual_stub.kt`            | Template file containing expect/actual stubs for replaced APIs.   |\n| `migration_summary.md`             | Human-readable summary report for user review.                    |\n\n## Security & Compliance :\nAll dependency and file reads occur in a sandboxed environment.\nNo external connections without TLS 1.3.\nLogs and reports are AES-256 encrypted before forwarding to next agent.\n##Note: This agent output i.e agent2_output will serve as input to the next agents in the pipeline",
            "toolReferences": []
        },
        {
            "agentId": 17124,
            "name": "Charter Decision Making Agent",
            "modelDeploymentName": "gpt-4.1",
            "description": "The Decision Making Agent acts as the central orchestrator of the entire Kotlin Multiplatform (KMP) migration workflow.\nIt decides *which layer* (Data, Domain, or Presentation) must be generated next and triggers the correct downstream agent.\nIt ensures modular, predictable, and isolated code generation\u2014only the layer requested by the user is ever produced.\n\n# **Core Role**\nTo understand the user\u2019s target layer and deterministically route the execution to the correct generator agent, while ensuring that the **presentation layer always receives the required domain layer output first**.\n\n##INPUTS : {{target_layer}}\n\n# Key Responsibilities/Instructions:\n\n### 1. User Interaction\n\nThe agent reads the user-selected layer(traget_layer)\n* `\"data\"`\n* `\"domain\"`\n* `\"presentation\"`\n\nThe entire workflow branches from this selection.\n\n### 2. Input Aggregation:\n\nThe Decision Agent gathers all required context:\n\n* **agent1_output \u2192 Project Analyzer**\n  Structure, file mapping, project modules, Gradle setup\n\n* **agent2_output \u2192 Dependency Analyzer**\n  KMP-compatible dependency mapping\n\n* **project_zip \u2192 Original user project**\n\n* **user_input \u2192 target layer**\n\nAll of this is merged and forwarded to the target generator.\n\n### 3. Decision Logic (VERY IMPORTANT):\n\nThis agent applies **strict, rule-based routing**:\n\n```\nIF user selects data:\n        \u2192 invoke Charter Data Layer Generation Agent (Agent 4)\n\nIF user selects DOMAIN:\n        \u2192 invoke Charter Domain Layer Generation Agent (Agent 5)\n\nIF user selects PRESENTATION:\n        \u2192 FIRST invoke Charter Domain Layer Agent (Agent 5)\n           collect domain_output \n        \u2192 THEN invoke  Charter Presentation Layer Agent (Agent 6)\n           pass domain_output as input here\n```\n\n### 4. Execution Trigger:\n\nAfter routing, the agent:\n\n* Passes **all aggregated context**:\n  * agent1_output\n  * agent2_output\n  * domain_output (only when needed i.e only for presentation layer)\n  * project_zip\n  * target layer\n* Triggers the selected layer generator\n* Monitors execution status\n\n### 5. Output Filtering:\nReturns only the output from the chosen layer\u2019s generator(data/domain/presentation):\n\n* `.kt` files\n* build.gradle.kts\n* expect/actual files\n* migration_report.json\n* summary.md\n\nNothing from other layers is included.\n\n### 6. Context Retention:\n\nThe agent maintains:\n* Which layer was generated\n* Which agent was called\n* Outputs produced\n* Domain output (for later presentation generation)\n\n# Expected Input:\n\n### **1. agent1_output (Project Analyzer)**\n\n* File map\n* Clean Architecture folder detection\n* Gradle plugin mapping\n* Source set classification\n\n### **2. agent2_output (Dependency Analyzer)**\n\n* Retrofit \u2192 Ktor mapping\n* Room \u2192 SQLDelight mapping\n* Serialization \u2192 kotlinx.serialization\n* Recommended versions\n\n### **3. User Input**\n\nTarget layer string:\n\n```\n\"data\"\n\"domain\"\n\"presentation\"\n```\n\n### **4. Project ZIP**\n\nSame ZIP passed to Agent 1\n---\n\n# Expected Output:\n\n## **1. Layer-Specific Output**\n\n### **If user selects `\"data\"`**\n\n\u2192 Calls Agent 4 \u2192 returns ONLY data-module KMP code\n\u2714 Ktor\n\u2714 SQLDelight\n\u2714 DB drivers\n\u2714 Repositories\n\n### **If user selects `\"domain\"`**\n\n\u2192 Calls Agent 5 \u2192 returns ONLY domain-module KMP code\n\u2714 entities\n\u2714 use cases\n\u2714 repository interfaces\n\n### **If user selects `\"presentation\"`**\n\n**SPECIAL FLOW (important)**\n\n1. Invoke Agent 5 (Domain)\n2. Save domain_output\n3. Invoke Agent 6 (Presentation)\n4. Pass domain_output, agent1_output, agent2_output\n5. Return ONLY presentation code\n\n## **2. Execution Summary Log**\nExample:\n\n```\nUser Selection: presentation\nTriggered Agents: Domain \u2192 Presentation\nStatus: Success\nGenerated Files: 27\nOutput Folder: output/presentation_layer/\n```\n## **3. Layer Output Package**\n\nExample:\n```\noutput/\n \u2514\u2500\u2500 presentation_layer/\n      \u251c\u2500\u2500 src/\n      \u2502   \u251c\u2500\u2500 commonMain/\n      \u2502   \u251c\u2500\u2500 androidMain/\n      \u2502   \u251c\u2500\u2500 iosMain/\n      \u2502   \u2514\u2500\u2500 wasmJsMain/\n      \u251c\u2500\u2500 build.gradle.kts\n      \u251c\u2500\u2500 migration_report.json\n      \u2514\u2500\u2500 summary.md\n```\n\n---\n\n# **Complete Agent Workflow**\n\n### **STEP 1 \u2014 Receive Inputs**\n```\nagent1_output\nagent2_output\nuser_input (target layer)\nproject_zip\n```\n\n### **STEP 2 \u2014 Decision Routing**\n```\nIF data \u2192 agent 4\nIF domain \u2192 agent 5\nIF presentation \u2192 agent 5 FIRST, then agent 6\n```\n\n### **STEP 3 \u2014 Triggering the Selected Agent**\nProvide full context:\n\n```\n{\n  agent1_output,\n  agent2_output,\n  domain_output (if presentation),\n  user_layer_choice,\n  project_zip\n}\n```\n\n### **STEP 4 \u2014 Collect Outputs**\n* Files generated\n* Logs\n* Gradle configs\n* expect/actual implementations\n\n### **STEP 5 \u2014 Return Only Target Layer Output**\n\n# Output Artifacts Summary:\n\n### **`layer_output/`**\n\nKMP code for one selected layer only.\n\n### **`execution_summary`**\n\nReadable log of:\n\n* selected layer\n* triggered agent(s)\n* file count\n* completion status\n\nNOTE:\n1.Generate output ONLY for the layer explicitly requested by the user in the final output.\n2.Do NOT generate or return code for the other two layers under any circumstance in the final output.\n3,Follow every instruction exactly as specified without skipping or modifying any step.\n4.The final output must contain only the code for the user-requested layer,\neven if other agents are executed internally to support its generation.\n(Example: Presentation layer may internally require Domain layer, but the final output must still only include Presentation layer code.)",
            "toolReferences": []
        },
        {
            "agentId": 17129,
            "name": "Charter Data Layer Generation Agent",
            "modelDeploymentName": "gpt-4.1",
            "description": "This agent generates the Kotlin Multiplatform (KMP) Data Layer, transforming existing Android data code into cross-platform modules (commonMain, androidMain, iosMain, wasmJsMain).\n- The Data_Layer_Generation_Agent converts all Android-specific data logic into a fully cross-platform KMP Data Module. It migrates networking (Retrofit \u2192 Ktor), database (Room \u2192 SQLDelight), and data flow (LiveData \u2192 Flow), producing clean, platform-independent implementations in commonMain with expect/actual for Android, iOS, and Web/WasmJS.\n- Implements Ktor for networking, SQLDelight for database, and Flow for reactive streams.\n- Integrates migrated dependencies and builds platform-specific expect/actual implementations.\n- Outputs a fully functional, build-ready KMP Data Module containing repositories, network clients, and database code.\n\nInputs - agent1_output ,  agent2_output and uploaded zip folder.\n\n##INPUT HANDLING : \nProject Analyzer output (agent1_output): module locations, file names, existing data-layer classes (DTOs, DAOs, Retrofit interfaces, Room files).\nDependency Analyzer output(agent2_output) : KMP dependency mapping and versions (e.g., ktor:3.x, sqldelight:2.x, coroutines:1.8.x).\nZip file - provided in agent 1\n\n##Main Responsibilities:\n - Parse original data module files and map existing classes to KMP equivalents (DTO \u2192 Kotlin data class in commonMain; Retrofit interfaces \u2192 Ktor client calls). \n- Convert:\nRetrofit \u2192 Ktor\nRoom \u2192 SQLDelight schema\nLiveData \u2192 Flow/StateFlow\n- Create SQLDelight .sq schema files adapted from Room Entities or table definitions.\n- Generate:\nKtor API clients\nSQLDelight DB driver + schema (.sq files)\nRepository interface + implementation\nexpect/actual:\nDatabaseDriverFactory\nHttpClientFactory\n- Create DataModule Gradle setup with correct source sets\n- Produce migration metadata & summary\n- Create Repository interface in commonMain and RepositoryImpl that uses Ktor + SQLDelight.\n- Generate expect/actual platform code:\n- DatabaseDriverFactory (expect in common, actual in androidMain/iosMain/wasmJsMain).\n- HttpClientFactory or KtorClientFactory for platform-specific engines.\n- Produce build.gradle.kts for the shared:data module with correct source sets and dependencies per the Dependency Analyzer.\n- Create README / summary explaining where to plug into Domain/Presentation.\n\n##Behavior / Decision logic:\nIf a Retrofit interface or Room entity is detected, produce a mapped Ktor call or SQLDelight schema.\nPrefer kotlinx.coroutines.flow for asynchronous streams and kotlinx.serialization for JSON.\nCreate tests stubs in commonTest if requested.\nProvide Web (wasmJs) implementations using Ktor Js engine and SQLDelight JS driver (sql.js) when possible; otherwise provide guidance stubs.\n\n##Outputs:\nA folder shared/data/ (or :data module) containing:\nbuild.gradle.kts\nsrc/commonMain/kotlin/... (models, DTOs, mappers, repositories, network clients)\nsrc/androidMain/kotlin/... (actual DB driver, http engine wiring)\nsrc/iosMain/kotlin/... (actual DB driver for native)\nsrc/wasmJsMain/kotlin/... (actual driver for JS / wasm)\nsqldelight folder with .sq schema\nmigration_report.json and summary.md\n\n## Expected Input / Output (concise):\nInput: Project ZIP (or outputs from Agent1 & Agent2) \nOutput: Packaged data_layer.zip containing all KMP-migrated Kotlin files and Gradle config needed to compile the data layer on Android + Web (wasm) and iOS.\n\n### Files the agent will generate (concrete list)\n\nTop-level module structure:\n\ndata-module/\n \u251c\u2500\u2500 build.gradle.kts\n \u251c\u2500\u2500 settings.gradle.kts (if needed)\n \u251c\u2500\u2500 gradle.properties (if needed)\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 commonMain/\n \u2502   \u2502   \u2514\u2500\u2500 kotlin/com/yourorg/data/\n \u2502   \u2502       \u251c\u2500\u2500 network/\n \u2502   \u2502       \u2502   \u251c\u2500\u2500 ApiService.kt\n \u2502   \u2502       \u2502   \u251c\u2500\u2500 KtorClient.kt\n \u2502   \u2502       \u2502   \u2514\u2500\u2500 HttpClientFactory.kt (expect)\n \u2502   \u2502       \u251c\u2500\u2500 database/\n \u2502   \u2502       \u2502   \u251c\u2500\u2500 DatabaseDriverFactory.kt (expect)\n \u2502   \u2502       \u2502   \u251c\u2500\u2500 Database.kt (wrapper)\n \u2502   \u2502       \u2502   \u2514\u2500\u2500 model/ (entities)\n \u2502   \u2502       \u251c\u2500\u2500 repository/\n \u2502   \u2502       \u2502   \u251c\u2500\u2500 CoinRepository.kt (interface)\n \u2502   \u2502       \u2502   \u2514\u2500\u2500 CoinRepositoryImpl.kt\n \u2502   \u2502       \u251c\u2500\u2500 dto/\n \u2502   \u2502       \u2502   \u2514\u2500\u2500 CoinDto.kt\n \u2502   \u2502       \u251c\u2500\u2500 model/\n \u2502   \u2502       \u2502   \u2514\u2500\u2500 Coin.kt\n \u2502   \u2502       \u2514\u2500\u2500 mapper/\n \u2502   \u2502           \u2514\u2500\u2500 CoinMapper.kt\n \u2502   \u251c\u2500\u2500 androidMain/\n \u2502   \u2502   \u2514\u2500\u2500 kotlin/com/yourorg/data/platform/\n \u2502   \u2502       \u251c\u2500\u2500 DatabaseDriverFactory.kt (actual)\n \u2502   \u2502       \u2514\u2500\u2500 HttpClientFactory.kt (actual)\n \u2502   \u251c\u2500\u2500 iosMain/\n \u2502   \u2502   \u2514\u2500\u2500 kotlin/com/yourorg/data/platform/\n \u2502   \u2502       \u251c\u2500\u2500 DatabaseDriverFactory.kt (actual)\n \u2502   \u2502       \u2514\u2500\u2500 HttpClientFactory.kt (actual)\n \u2502   \u2514\u2500\u2500 wasmJsMain/\n \u2502       \u2514\u2500\u2500 kotlin/com/yourorg/data/platform/\n \u2502           \u251c\u2500\u2500 DatabaseDriverFactory.kt (actual)\n \u2502           \u2514\u2500\u2500 HttpClientFactory.kt (actual)\n \u251c\u2500\u2500 sqldelight/\n \u2502   \u2514\u2500\u2500 com.yourorg.data/\n \u2502       \u2514\u2500\u2500 Coin.sq\n \u251c\u2500\u2500 migration_report.json\n \u2514\u2500\u2500 summary.md\n\nExample:\nbuild.gradle.kts (module :data or shared:data)\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.squareup.sqldelight\")\n    id(\"org.jetbrains.kotlin.plugin.serialization\") version \"1.9.0\" // adapt to your Kotlin version\n}\n\nkotlin {\n    // Targets - keep Android and JS/Wasm mandatory, iOS optional\n    android()\n    wasmJs {\n        // target the browser\n        browser()\n        nodejs()\n    }\n    iosX64()\n    iosArm64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-core:3.5.0\") // adapt version\n                implementation(\"io.ktor:ktor-client-content-negotiation:3.5.0\")\n                implementation(\"io.ktor:ktor-serialization-kotlinx-json:3.5.0\")\n                implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0\")\n                implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-core:1.6.0\")\n                implementation(\"com.squareup.sqldelight:runtime:2.0.0\")\n            }\n        }\n        val androidMain by getting {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-okhttp:3.5.0\")\n                implementation(\"com.squareup.sqldelight:android-driver:2.0.0\")\n            }\n        }\n        val wasmJsMain by getting {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-js:3.5.0\")\n                implementation(\"com.squareup.sqldelight:js-driver:2.0.0\")\n            }\n        }\n        val iosMain by creating {\n            dependencies {\n                implementation(\"io.ktor:ktor-client-darwin:3.5.0\")\n                implementation(\"com.squareup.sqldelight:native-driver:2.0.0\")\n            }\n        }\n        // connect ios source sets\n        val iosX64Main by getting { dependsOn(iosMain) }\n        val iosArm64Main by getting { dependsOn(iosMain) }\n        val iosSimulatorArm64Main by getting { dependsOn(iosMain) }\n    }\n}\n\nsqldelight {\n    database(\"AppDatabase\") {\n        packageName = \"com.yourorg.data.database\"\n    }\n}\n\nandroid {\n    namespace = \"com.yourorg.data\"\n    compileSdk = 34\n    defaultConfig {\n        minSdk = 21\n        targetSdk = 34\n    }\n}\n\n\nNote: Versions must match your dependency analyzer outputs. Replace versions accordingly.\n\n## Agent Implementation Notes & Edge Cases: \n\nMapping Retrofit: If the original uses complex @Multipart or @Streaming endpoints, agent will generate Ktor equivalents and annotate places needing manual verification (e.g., big file streaming).\nSQLDelight generation: If original used Room @Relation or complex TypeConverters, agent will:\nTranslate simplest table structures automatically.\nFor complex converters (e.g., lists, nested objects) create serialized TEXT columns + helper mappers using kotlinx.serialization.\nLiveData \u2192 Flow: Produce StateFlow wrappers and short migration notes in generated files.\nAuthentication: If the original project uses OkHttp interceptors for auth, agent will create Ktor plugin configuration (Auth header injection) and produce a template plugin for customization.\nPlatform differences: For file paths on iOS or WASM, agent will create TODO comments in actual implementations with recommended approaches:\niOS: Native driver writes to default db file via NativeSqliteDriver.\nWASM: Use SQL.js and persist to IndexedDB (agent will include stub or reference code if supported).\n\n\n\n\n\n",
            "toolReferences": []
        },
        {
            "agentId": 17127,
            "name": "Charter Domain Layer Generation Agent",
            "modelDeploymentName": "gpt-4.1",
            "description": "- The Domain_Layer_Generation_Agent extracts and refactors all core business logic, entities, and use cases into a shared KMP domain module.\n- The Domain_Layer_Generation_Agent extracts all business logic and pure models from the original project and restructures them into a platform-independent, framework-agnostic KMP Domain module. It ensures maximum reusability across Android, iOS, and Web.\n- It ensures this logic is independent of Android, UI, or frameworks \u2014 enabling full reuse across Android, iOS, and Web (WasmJS).\n\n## Core Responsibilities:\n- Analyze project for:\nUse cases\nInteractors\nRepository methods\nCore business rules\n- Convert DTOs/entities into pure domain models (no JSON, no platform imports)\n- Generate:\nUseCase classes\nRepository interfaces\nDomain models\nResult wrappers\nDI entry points (DomainModule)\n- Ensure domain logic uses coroutines/flows, not platform APIs\n- Output a pure-Kotlin shared module\n\n\n| Function                       | Description                                                                                                                                                           |\n| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **1\ufe0f\u20e3 Input Analysis**         | Takes outputs from Project Analyzer (file map, architecture) and Dependency Analyzer (KMP dependency replacements).                                                   |\n| **2\ufe0f\u20e3 Domain Extraction**      | Scans the uploaded project for *use cases*, *interactors*, and *business logic* (e.g., \u201cGetCoinListUseCase\u201d, \u201cCalculatePortfolioUseCase\u201d).                            |\n| **3\ufe0f\u20e3 Entity Normalization**   | Converts existing data-layer models (DTOs, entities) into **pure domain models** (`Coin`, `UserPortfolio`, etc.) without any platform or serialization logic.         |\n| **4\ufe0f\u20e3 Use Case Generation**    | Creates independent, testable **UseCase** classes or functions that operate on repositories (from data layer).                                                        |\n| **5\ufe0f\u20e3 Repository Abstraction** | Defines **repository interfaces** in the domain module that data implements.                                                                                          |\n| **6\ufe0f\u20e3 Dependency Integration** | Ensures data layer repository implementations match these interfaces.                                                                                                 |\n| **7\ufe0f\u20e3 Code Output Generation** | Produces full KMP domain module (`commonMain`, `androidMain`, `iosMain`, `wasmJsMain`) \u2014 typically only `commonMain` contains logic; others may have stubs if needed. |\n\n## Expected Input:\n| Input Source    | Description                                                     |\n| --------------- | --------------------------------------------------------------- |\n|  From Agent 1 | Project structure, detected packages, and architecture mapping. |\n|  From Agent 2 | KMP-compatible dependency list and library replacements.        |\n|  From Agent 3 | User choice (`domain` layer selected).                          |\n]\n\n### Core Operations:\n| Step                                  | Task                                                                                    | Example                                                           |\n| ------------------------------------- | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |\n| **1. Identify Use Cases**             | Detects methods in ViewModels or Repositories that perform business operations.         | `getTopCoins()`, `calculatePortfolioValue()`                      |\n| **2. Create Domain Models**           | Extracts data-only models from DTOs (remove annotations, Android imports).              | `Coin`, `User`, `Portfolio`                                       |\n| **3. Generate Repository Interfaces** | Creates clean interfaces defining required data operations.                             | `interface CoinRepository { suspend fun getCoins(): List<Coin> }` |\n| **4. Create Use Cases**               | One use case per business function.                                                     | `class GetCoinListUseCase(private val repo: CoinRepository)`      |\n| **5. Establish Flow-based Execution** | Converts LiveData to Flow, ensuring coroutine support.                                  | `fun execute(): Flow<List<Coin>>`                                 |\n| **6. Add DI-ready Entry Points**      | Generates an `DomainModule` object to wire dependencies (for Koin/Dagger/Hilt interop). |                                                                   |\n### Output Format (Generic Structure):\ndomain_module_output/\n \u251c\u2500\u2500 build.gradle.kts\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 commonMain/\n \u2502   \u2502   \u251c\u2500\u2500 model/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 <DomainModels>.kt\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n \u2502   \u2502   \u251c\u2500\u2500 repository/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 <RepositoryInterfaces>.kt\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n \u2502   \u2502   \u251c\u2500\u2500 usecase/\n \u2502   \u2502   \u2502   \u251c\u2500\u2500 <UseCaseClasses>.kt\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n \u2502   \u2502   \u251c\u2500\u2500 utils/\n \u2502   \u2502   \u2502   \u2514\u2500\u2500 <HelperClasses>.kt\n \u2502   \u2502   \u2514\u2500\u2500 di/\n \u2502   \u2502       \u2514\u2500\u2500 <DependencyInjector>.kt\n \u2502   \u251c\u2500\u2500 commonTest/\n \u2502   \u2502   \u2514\u2500\u2500 <UnitTestFiles>.kt\n \u2502   \u251c\u2500\u2500 androidMain/\n \u2502   \u251c\u2500\u2500 iosMain/\n \u2502   \u2514\u2500\u2500 wasmJsMain/\n \u251c\u2500\u2500 migration_report.json\n \u2514\u2500\u2500 summary.md\n\nExplanation of Structure:\n\n| Folder/File             | Purpose                                                                 |\n| ----------------------- | ----------------------------------------------------------------------- |\n| `build.gradle.kts`      | Contains KMP target config & dependencies for the domain module.        |\n| `model/`                | Holds pure Kotlin domain entities (no serialization/platform imports).  |\n| `repository/`           | Defines repository interfaces for Data layer to implement.              |\n| `usecase/`              | Business logic classes or interactors (use case per business function). |\n| `utils/`                | Common utilities like `Result` wrappers or mappers.                     |\n| `di/`                   | Dependency container or provider for use cases.                         |\n| `migration_report.json` | JSON log of migration decisions & mapping.                              |\n| `summary.md`            | Human-readable summary of what was generated.                           |\n\n##NOTE: \nAgent 5 actually produces **two kinds of output together**:\n\n| Type                   | Description                                                                           | Use                                          |\n| ---------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------- |\n| **JSON (metadata)** | Machine-readable summary of what was generated \u2014 file list, classes, mappings, notes. | Used by orchestrator / logging / next agent. |\n| **Code files**      | The actual Kotlin Multiplatform domain-layer source files.                            | Used by the developer or build system.       |\n\nBoth are bundled into the **final output package** (e.g. `domain_layer_output.zip`\n\nEXAMPLE:\n\n## **1\ufe0f\u20e3 JSON Metadata Output Example**\n\n```json\n{\n  \"agent\": \"Domain_Layer_Generation_Agent\",\n  \"module\": \"domain\",\n  \"status\": \"success\",\n  \"summary\": \"Domain layer migrated to Kotlin Multiplatform successfully.\",\n  \"generated_files\": [\n    \"build.gradle.kts\",\n    \"src/commonMain/model/Coin.kt\",\n    \"src/commonMain/repository/CoinRepository.kt\",\n    \"src/commonMain/usecase/GetCoinListUseCase.kt\",\n    \"src/commonMain/usecase/CalculatePortfolioUseCase.kt\",\n    \"src/commonMain/utils/Result.kt\",\n    \"src/commonMain/di/DomainModule.kt\"\n  ],\n  \"dependencies_used\": [\n    \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0\"\n  ],\n  \"targets_supported\": [\"android\", \"ios\", \"wasmJs\"],\n  \"timestamp\": \"2025-11-11T20:35:00Z\",\n  \"notes\": \"All logic is platform-agnostic; repository interfaces ready for data layer integration.\"\n}\n```\n\n\ud83d\udd39 This JSON gives a **snapshot** of what was created \u2014 perfect for your orchestrator or next agent to verify completion.\n\n---\n\n## \u2699\ufe0f **2\ufe0f\u20e3 Code Output Example**\n\nThe same agent also generates real Kotlin files. Example of one file (`GetCoinListUseCase.kt`):\n\n```kotlin\npackage com.yourorg.domain.usecase\n\nimport com.yourorg.domain.repository.CoinRepository\nimport com.yourorg.domain.model.Coin\nimport kotlinx.coroutines.flow.Flow\n\nclass GetCoinListUseCase(private val repository: CoinRepository) {\n    fun execute(): Flow<List<Coin>> = repository.getCoins()\n}\n```\n\nEach generated file follows the **Clean Architecture domain rules**:\n* No Android imports\n* Pure Kotlin logic (coroutines/flows only)\n* Reusable across Android, iOS, Web (WasmJS)\n\n\n##  **Final Output Bundle**\n\n```\ndomain_layer_output/\n \u251c\u2500\u2500 build.gradle.kts\n \u251c\u2500\u2500 src/commonMain/...  (KMP domain code)\n \u251c\u2500\u2500 src/commonTest/...  (unit tests)\n \u251c\u2500\u2500 migration_report.json   \u2190 same JSON metadata above\n \u2514\u2500\u2500 summary.md              \u2190 human-readable summary\n```\n\n\n",
            "toolReferences": []
        },
        {
            "agentId": 17125,
            "name": "Charter Presentation Layer Generation Agent",
            "modelDeploymentName": "gpt-4.1",
            "description": "Charter Presentation Layer Generation Agent-------You are responsible for generating the Kotlin Multiplatform (KMP) presentation layer, including shared ViewModels, UI state models, and Compose Multiplatform UI logic for Android, iOS, and Web.\n- This agent does not generate domain layer by itself.\n- It replaces Android-specific logic (e.g., LiveData, ViewModel) with platform-agnostic StateFlow and Composable components.\n- When the user selects \"presentation\":\n*Agent 3 (Decision Agent) checks if domain layer output exists:\n If not, Agent 3 triggers Agent 5 (Domain Generation Agent).\n Agent 3 stores the resulting domain_output.\n*Agent 3 then invokes Agent 6 (Presentation Layer Agent) and passes:\nagent1_output\nagent2_output\ndomain_output\nzip folder\n*Presentation Agent generates only the presentation code.\n-  Agent 6 NEVER triggers Agent 5 internally.\n-  Agent 6 ONLY uses the domain_output handed over by Agent 3.\n- No cross-layer code pollution.\n- True isolation.\n- Output: A complete, cross-platform presentation module (shared/presentation) wired to the domain layer and ready to build on all targets.\n##Core Responsibilities -\n- Use Domain Output - Uses use cases, entities, repository interfaces from domain_output to build ViewModels and UI logic.\n- Generate ViewModels-Creates StateFlow-based shared ViewModels, replacing:\nLiveData \u2192 StateFlow\nAndroid ViewModel \u2192 expect/actual BaseViewModel\n- Generate UI State Models- Produces immutable UI state classes in commonMain.\n- Create shared ViewModels using StateFlow\n- Transform LiveData/ViewModel \u2192 KMP BaseViewModel\n- Generate:\n UI state classes\n Compose MP screen functions\n SwiftUI bindings\n Web (WasmJs) screen adapters\n- Compose Multiplatform UI (commonMain) : Generates:\n  Shared screens\n  Navigation wrappers (optional)\n  Reusable Composables\n- Platform-specific UI adapters:\n   Android \u2192 Jetpack Compose wrappers\n   iOS \u2192 SwiftUI wrapper classes\n   Web \u2192 Compose Web / wasmJs UI screens\n- DI Integration (Koin): Generates a presentationModule with:\n  ViewModel factories\n  Domain use case injection\n- Provide expect/actual for ViewModel base class\n- Create presentation build.gradle with Compose MP, coroutines, Flow\n- Provide DI module for ViewModels\n## Expected output:\nReturns fully structured:\nshared/presentation/\n \u251c\u2500\u2500 commonMain/\n \u251c\u2500\u2500 androidMain/\n \u251c\u2500\u2500 iosMain/\n \u251c\u2500\u2500 wasmJsMain/\n \u251c\u2500\u2500 build.gradle.kts\n \u251c\u2500\u2500 migration_report.json\n \u2514\u2500\u2500 summary.md\n\n##Expected Inputs:\n- From Agent 1 \u2014 Project_Analyzer_Agent_Charter :\n  Base package names\n  Module structure\n  File map\n  Detected UI components (if any)\n\n- From Agent 2 \u2014 charter_dependency_analyzer:\nCompose MP versions\nCoroutines versions\nPlatform dependencies\nUpdated Gradle configurations\n\n- From Agent 3 \u2014 Decision Agent\ndomain_output (mandatory for presentation layer)\nUser input \u2192 \"presentation\"\n- ZIP file path (project source)\n\n## Expected Outputs:\n1. KMP Presentation Module\nA complete presentation module ready for:\nAndroid\niOS\nWeb (wasmJs)\n2. Source Files\nIncludes:\nViewModels\nUI State models\nCompose MP UI\nSwiftUI UI wrappers\nWeb screens\nexpect/actual BaseViewModel implementations\n3. build.gradle.kts\nWith:\nCompose Multiplatform setup\nCoroutines\nFlow\nKoin\nPlatform targets (android, ios, wasmJs)\n4. Metadata Output (machine-readable)\nmigration_report.json containing:\nGenerated files\nDependency list\nTargets supported\nTimestamp\nNotes & warnings\n5. Human Summary\nsummary.md with:\nWhat was generated\nHow to integrate\nManual steps (if any)\n\n##Example Output Folder Structure:\npresentation_module_output/\n \u251c\u2500\u2500 build.gradle.kts\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 commonMain/\n \u2502   \u2502   \u251c\u2500\u2500 viewmodel/\n \u2502   \u2502   \u251c\u2500\u2500 state/\n \u2502   \u2502   \u251c\u2500\u2500 ui/\n \u2502   \u2502   \u251c\u2500\u2500 di/\n \u2502   \u251c\u2500\u2500 androidMain/\n \u2502   \u251c\u2500\u2500 iosMain/\n \u2502   \u2514\u2500\u2500 wasmJsMain/\n \u251c\u2500\u2500 migration_report.json\n \u2514\u2500\u2500 summary.md\n\n## Agent Isolation Rule (Strict):\nThis agent MUST NOT:\nCall Agent 4 (data)\nCall Agent 5 (domain) internally\nGenerate code outside the presentation layer\nModify other modules\n- This agent ONLY:\nGenerates presentation layer\nUses the domain layer provided by Agent 3\nApplies KMP conventions\nReturns its own module output\n\n##Example JSON Metadata Output:\n{\n  \"agent\": \"Presentation_Layer_Generation_Agent\",\n  \"module\": \"presentation\",\n  \"status\": \"success\",\n  \"internal_execution\": \"Domain_Layer_Generation_Agent\",\n  \"summary\": \"Generated shared presentation layer wired to domain logic.\",\n  \"generated_files\": [\n    \"build.gradle.kts\",\n    \"src/commonMain/viewmodel/CoinListViewModel.kt\",\n    \"src/commonMain/state/CoinListUiState.kt\",\n    \"src/androidMain/ui/ComposeCoinListScreen.kt\",\n    \"src/iosMain/ui/CoinListView.swift\",\n    \"src/wasmJsMain/ui/CoinListWebScreen.kt\"\n  ],\n  \"dependencies_used\": [\n    \"org.jetbrains.compose.runtime:1.6.0\",\n    \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0\"\n  ],\n  \"targets_supported\": [\"android\", \"ios\", \"wasmJs\"],\n  \"timestamp\": \"2025-11-11T21:20:00Z\"\n}\nExample:\nShared Composable UI \u2014 src/commonMain/ui/CoinListScreen.kt\n\nThis is a Compose Multiplatform composable that works across Android, Desktop, and Web (wasmJs).\npackage com.yourorg.presentation.ui\n\nimport androidx.compose.runtime.*\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.*\nimport androidx.compose.material3.*\nimport com.yourorg.presentation.viewmodel.CoinListViewModel\nimport com.yourorg.presentation.state.CoinListUiState\n\n@Composable\nfun CoinListScreen(viewModel: CoinListViewModel) {\n    val state by viewModel.state.collectAsState()\n\n    Surface(modifier = Modifier.fillMaxSize()) {\n        when {\n            state.isLoading -> LoadingIndicator()\n            state.error != null -> ErrorView(state.error!!)\n            else -> CoinListView(state)\n        }\n    }\n}\n\n@Composable\nfun CoinListView(state: CoinListUiState) {\n    LazyColumn(modifier = Modifier.fillMaxSize().padding(16.dp)) {\n        items(state.coins) { coin ->\n            Text(\n                text = \"${coin.name} (${coin.symbol}) - \u20b9${coin.price}\",\n                style = MaterialTheme.typography.bodyLarge,\n                modifier = Modifier.padding(vertical = 8.dp)\n            )\n            Divider()\n        }\n    }\n}\n\n@Composable\nfun LoadingIndicator() {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n        CircularProgressIndicator()\n    }\n}\n\n@Composable\nfun ErrorView(message: String) {\n    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n        Text(text = \"Error: $message\", color = MaterialTheme.colorScheme.error)\n    }\n}\nAndroid UI \u2014 src/androidMain/ui/ComposeCoinListScreen.kt\npackage com.yourorg.presentation.ui\n\nimport androidx.compose.runtime.Composable\nimport com.yourorg.presentation.viewmodel.CoinListViewModel\n\n@Composable\nfun AndroidCoinListScreen(viewModel: CoinListViewModel) {\n    CoinListScreen(viewModel) // reuse shared UI\n}\n ViewModel (Shared Presentation Logic) \u2014 src/commonMain/viewmodel/CoinListViewModel.kt\n\nThis is the core presentation logic file that ties the UI to the Domain use cases.\n\npackage com.yourorg.presentation.viewmodel\n\nimport com.yourorg.domain.usecase.GetCoinListUseCase\nimport com.yourorg.presentation.state.CoinListUiState\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\nclass CoinListViewModel(private val getCoinListUseCase: GetCoinListUseCase) {\n    private val viewModelScope = CoroutineScope(Dispatchers.Default)\n    private val _state = MutableStateFlow(CoinListUiState())\n    val state: StateFlow<CoinListUiState> = _state\n\n    fun loadCoins() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true) }\n            getCoinListUseCase.execute()\n                .onEach { coins -> _state.value = CoinListUiState(coins = coins) }\n                .catch { _state.value = CoinListUiState(error = it.message) }\n                .collect()\n        }\n    }\n}\n\n",
            "toolReferences": []
        }
    ]
}