# Detailed Documentation for SQL Server Stored Procedure: uspAPIPatchAccount

## 1. Overview of Program

### Purpose
The stored procedure `uspAPIPatchAccount` is designed to generate PATCH data in JSON format for API integration related to account information. It retrieves account data that requires updating and formats it into a structured JSON payload with PATCH operations (replace operations) for each field. The procedure supports batched processing of accounts to manage data volume efficiently.

### Business Problem Addressed
This stored procedure addresses the business need to synchronize account data between internal systems and external APIs. It enables incremental updates to account information by identifying accounts that need patching (where `PostPatch = 'Patch'`) and have not yet been processed (where `Validated IS NULL` and `DateSent IS NULL`). The procedure handles special cases like national accounts and ensures data quality by validating email formats and handling null values appropriately. It supports the organization's need to maintain consistent account information across systems while optimizing API calls through batched processing.

## 2. Code Structure and Design

### Structure and Flow
The stored procedure follows this logical flow:
1. Declares a date variable for filtering national accounts
2. Defines four Common Table Expressions (CTEs):
   - `NationalAccts`: Identifies national accounts with non-expired policies
   - `INForceListCode`: Maps status codes to descriptive text
   - `BrandCode`: Maps brand IDs to brand names
   - `Final`: Main CTE that joins tables and prepares data for JSON formatting
3. Filters accounts that need patching and have not been processed
4. Formats the data into JSON PATCH operations
5. Returns the JSON payload for the specified batch (LoopInstance)

### Primary SQL Server Components
- **Tables**:
  - `RCT.Account`: Primary source of account information
  - `EDSMART.Semantic.PolicyDescriptors`: Used to identify national accounts
  - `RCT.AccountID`: Maps contact numbers to account IDs
  - `RCT.IdOverride`: Contains override IDs for accounts

- **Views**: None used directly

- **Stored Procedures**: 
  - `RCT.uspAPIPatchAccount`: The procedure itself

- **Joins**:
  - LEFT JOIN between `RCT.Account` and `NationalAccts` CTE
  - LEFT JOIN between `RCT.Account` and `INForceListCode` CTE
  - LEFT JOIN between `RCT.Account` and `BrandCode` CTE
  - LEFT JOIN between `RCT.Account` and `RCT.AccountID`
  - LEFT JOIN between `RCT.Account` and `RCT.IdOverride`

- **Aggregations**:
  - ROW_NUMBER() for batch calculation
  - ROW_NUMBER() for sorting by premium amount

- **Subqueries**: None used directly (logic implemented via CTEs instead)

## 3. Data Flow and Processing Logic

### Processing Logic Components
1. **National Account Identification**:
   - Functionality: Identifies accounts flagged as national accounts with non-expired policies
   - Transformations: Filters PolicyDescriptors where NationalAccountFlag = 1 and ExpirationDate > current date

2. **Status Code Mapping**:
   - Functionality: Maps numeric status codes to descriptive text
   - Transformations: Hardcoded mapping of ItemID to ItemCode for account statuses

3. **Brand Code Mapping**:
   - Functionality: Maps numeric brand codes to brand names
   - Transformations: Hardcoded mapping of ItemID to ItemCode for brands

4. **Account Data Preparation**:
   - Functionality: Retrieves and formats account data for API integration
   - Transformations:
     - Joins multiple tables to gather complete account information
     - Handles special case for national accounts (removing UnderwriterId)
     - Formats address information into structured format
     - Prepares extension fields with appropriate IDs
     - Validates email addresses using LIKE '%@%'
     - Calculates batch number using ROW_NUMBER() and integer division

5. **JSON Construction**:
   - Functionality: Builds JSON PATCH operations for each field
   - Transformations:
     - Uses COALESCE to conditionally include fields
     - Formats each field as a PATCH operation with "op": "replace"
     - Builds nested structure for extension fields
     - Handles special formatting for required fields

6. **Batch Processing**:
   - Functionality: Processes accounts in batches of 250
   - Transformations:
     - Calculates LoopInstance using ROW_NUMBER() and integer division
     - Filters final output based on @LoopInstance parameter

## 4. Data Mapping

### Core Account Fields

| Target Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks |
|-------------------|-------------------|-------------------|-------------------|---------|
| JSON Output | AccountID | RCT.AccountID/RCT.IdOverride | COALESCE(AC.AccountID,ID.RCT_ID) | 1 to 1 mapping |
| JSON Output | UnderwriterId | RCT.Account | UnderwriterId | Transformation - Set to NULL for National Accounts |
| JSON Output | Name | RCT.Account | Name | 1 to 1 mapping |
| JSON Output | Phone | RCT.Account | BusinessPhone | 1 to 1 mapping |
| JSON Output | Fax | RCT.Account | FaxPhone | 1 to 1 mapping |
| JSON Output | Email | RCT.Account | EmailAddress | Validation - Only if contains '@' |
| JSON Output | Notes | RCT.Account | Notes | Transformation - Limited to 150 chars |
| JSON Output | ContactNumber | RCT.Account | ContactNumber | 1 to 1 mapping |

### Mailing Address Fields

| Target Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks |
|-------------------|-------------------|-------------------|-------------------|---------|
| JSON Output | MailingAddress.ProvinceID | RCT.Account | MailingAddressProvinceId | 1 to 1 mapping |
| JSON Output | MailingAddress.AddressLine | RCT.Account | MailingAddressAddressLine | 1 to 1 mapping |
| JSON Output | MailingAddress.City | RCT.Account | MailingAddressCity | 1 to 1 mapping |
| JSON Output | MailingAddress.PostalCode | RCT.Account | MailingAddressPostalCode | 1 to 1 mapping |
| JSON Output | MailingAddress.Longitude | RCT.Account | MailingAddressLongitude | 1 to 1 mapping |
| JSON Output | MailingAddress.Latitude | RCT.Account | MailingAddressLatitude | 1 to 1 mapping |
| JSON Output | MailingAddress.County | RCT.Account | MailingAddressCounty | 1 to 1 mapping |

### Location Address Fields

| Target Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks |
|-------------------|-------------------|-------------------|-------------------|---------|
| JSON Output | Location.Address.ProvinceID | RCT.Account | PrimaryLocationAddressProvinceId | 1 to 1 mapping |
| JSON Output | Location.Address.AddressLine | RCT.Account | PrimaryLocationAddressAddressLine | 1 to 1 mapping |
| JSON Output | Location.Address.City | RCT.Account | PrimaryLocationAddressCity | 1 to 1 mapping |
| JSON Output | Location.Address.PostalCode | RCT.Account | PrimaryLocationAddressPostalCode | 1 to 1 mapping |
| JSON Output | Location.Address.Longitude | RCT.Account | PrimaryLocationAddressLongitude | 1 to 1 mapping |
| JSON Output | Location.Address.Latitude | RCT.Account | PrimaryLocationAddressLatitude | 1 to 1 mapping |
| JSON Output | Location.Address.County | RCT.Account | PrimaryLocationAddressCounty | 1 to 1 mapping |
| JSON Output | Location.ExternalUniqueId | RCT.Account | PrimaryLocationAddressExternalUniqueId | Transformation - Cast to VARCHAR(100) |
| JSON Output | Location.LocationNumber | RCT.Account | PrimaryLocationAddressLocationNumber | 1 to 1 mapping |
| JSON Output | Location.Description | RCT.Account | PrimaryLocationAddressDescription | 1 to 1 mapping |
| JSON Output | Location.AdditionalInfo | RCT.Account | PrimaryLocationAddressAdditionalInfo | 1 to 1 mapping |

### Key Extension Fields

| Target Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks |
|-------------------|-------------------|-------------------|-------------------|---------|
| JSON Output | ExtensionFields[11] | INForceListCode CTE | F.ItemID | Transformation - Account status code |
| JSON Output | ExtensionFields[37] | RCT.Account | BDCName | 1 to 1 mapping |
| JSON Output | ExtensionFields[116] | BrandCode CTE | B.ItemID | Transformation - Brand code |
| JSON Output | ExtensionFields[120] | RCT.Account | NewBusinessPolicyFlag | Transformation - '2444' if 1, else '2445' |
| JSON Output | ExtensionFields[167] | RCT.Account | ExternalUniqueId/ContactNumber | Transformation - Modified ID |
| JSON Output | ExtensionFields[168] | RCT.Account | WrittenLossRatio | 1 to 1 mapping |

## 5. Complexity Analysis

| Complexity Factor | Count/Value | Description |
|-------------------|-------------|-------------|
| Lines of Code (LOC) | 325 | Total lines in the procedure |
| Cyclomatic Complexity | 3 | Limited conditional logic using IIF and COALESCE |
| Nesting Depth | 2 | CTEs â†’ main query |
| Tables | 4 | RCT.Account, EDSMART.Semantic.PolicyDescriptors, RCT.AccountID, RCT.IdOverride |
| Temporary Tables | 0 | Uses CTEs instead of temp tables |
| DML Statements | 1 | SELECT statement (read-only procedure) |
| Joins | 5 | Multiple LEFT JOINs to gather account data |
| Subqueries | 0 | Logic implemented via CTEs instead |
| CTEs | 4 | NationalAccts, INForceListCode, BrandCode, Final |
| Aggregation Queries | 2 | ROW_NUMBER() functions for ordering and batching |
| Input Parameters | 1 | @LoopInstance INT |
| Output Parameters | 0 | Returns result set directly |
| Data Transformations | 60+ | Extensive string manipulations and formatting |
| Function Calls | 20+ | COALESCE, IIF, CAST, DATEADD, etc. |
| **Overall Complexity Score** | **75/100** | High complexity due to extensive data transformations and JSON formatting |

## 6. Key Outputs

The stored procedure produces a result set with the following key outputs:

1. **AccountID**: The unique identifier for the account
2. **ContactNumber**: The contact number associated with the account
3. **SubmissionFlag**: Flag indicating submission status
4. **LoopInstance**: The batch number for processing
5. **JSON_Message**: A complex JSON structure containing PATCH operations for the account, including:
   - Core account fields (Name, Phone, Email, etc.)
   - Mailing address information
   - Location address information
   - Extensive extension fields (over 60 different fields)

The JSON output follows the PATCH operation format with "op": "replace" for each field, allowing the API to selectively update account information. The procedure does not perform any direct inserts, updates, or deletes to the database; it only prepares data for API consumption.

## 7. Error Handling and Logging

The stored procedure implements the following error handling and logging mechanisms:

1. **Null Value Handling**:
   - Extensive use of COALESCE to handle NULL values in the source data
   - IIF statements to provide default values when needed (e.g., 'Unknown' for missing phone numbers)
   - Conditional inclusion of fields in the JSON output based on NULL checks

2. **Data Validation**:
   - Email validation using LIKE '%@%' to ensure valid email format
   - Filtering for accounts that need patching and have not been processed

3. **Batch Processing**:
   - Uses @LoopInstance parameter to process accounts in manageable batches
   - Prevents timeout issues when dealing with large datasets

4. **Tracking Mechanisms**:
   - Filters on PostPatch, Validated, and DateSent columns to track processing status
   - SubmissionFlag to track submission status

The procedure does not implement explicit Try-Catch blocks or SQL Server Error Logging Tables, relying instead on the calling application to handle any errors that might occur during execution. The procedure's focus is on data preparation rather than transaction management or error recovery.