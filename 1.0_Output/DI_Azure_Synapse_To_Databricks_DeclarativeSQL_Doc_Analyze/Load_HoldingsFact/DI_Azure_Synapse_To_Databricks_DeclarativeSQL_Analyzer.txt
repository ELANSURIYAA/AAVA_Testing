```
=============================================
Author:        AAVA
Created on:   
Description:   Loads FACT_EXECUTIVE_SUMMARY table with summarized holding metrics from staging and dimension tables.
=============================================

**1. Procedure Overview**

This Azure Synapse stored procedure (`dbo.LOAD_FACT_EXECUTIVE_SUMMARY`) aggregates and loads holding metrics from the staging table `STG_HOLDING_METRICS` into the `FACT_EXECUTIVE_SUMMARY` fact table. It performs business rule validations (such as income amount normalization), joins with multiple dimension tables for referential integrity, and ensures data quality for executive reporting, regulatory analytics, and downstream BI/ML use cases.

**2. Complexity Metrics**

| Metric                                 | Description                                                                 | Value/Details                                                                 |
|-----------------------------------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| Number of Input Tables                  | Count of distinct source tables used in the procedure.                      | 5 (`STG_HOLDING_METRICS`, `DIM_DATE`, `DIM_INSTITUTION`, `DIM_CORPORATION`, `DIM_PRODUCT`) |
| Number of Output Tables                 | Count of target or intermediate tables modified or populated.               | 1 (`FACT_EXECUTIVE_SUMMARY`)                                                  |
| Variable Declarations                   | Number of declared variables and their usage complexity.                    | 2 (`@v_row_count`, `@error_message`) - used for row count and error handling  |
| Conditional Logic                       | Number of IF, CASE, or nested conditional blocks.                           | 1 (CASE statement for `income_amount` normalization)                          |
| Loop Constructs                         | Number of WHILE or FOR loops, if present.                                   | 0                                                                             |
| Join Conditions                         | Count and types of joins (INNER, LEFT, RIGHT, FULL).                        | 4 INNER JOINs (to dimension tables)                                           |
| Aggregations                            | Number of aggregation operations (SUM, COUNT, AVG, etc.).                   | 0 (No explicit aggregation, only data normalization and mapping)              |
| Subqueries / CTEs                       | Number of subqueries or Common Table Expressions used.                      | 0 (No explicit subqueries or CTEs)                                            |
| Procedural Calls                        | Number of stored procedure or function invocations.                         | 0 (No nested procedure/function calls)                                        |
| DML Operations                          | Frequency of INSERT, UPDATE, DELETE, MERGE operations.                      | 1 (INSERT INTO fact table)                                                    |
| Temporary Tables / Table Variables      | Number of temp tables or table variables created and used.                  | 1 (Temporary table for staging)                                               |
| Transaction Handling                    | Count of BEGIN TRAN, COMMIT, ROLLBACK statements.                           | 0 (No explicit transaction blocks)                                            |
| Error Handling Blocks                   | Presence and count of TRY...CATCH logic.                                    | 0 (No TRY...CATCH blocks)                                                     |
| Complexity Score (0â€“100)                | Based on nested logic, control flow, DML count, and procedural depth.       | 30                                                                            |

**High-Complexity Areas:**
- Multiple joins to dimension tables for referential integrity.
- Business rule transformation using CASE statement.
- Use of temporary table for staging data.

**3. Syntax Differences**

- **Variable Declarations:** T-SQL `DECLARE @var` is not supported in Databricks declarative SQL. Any logic relying on variables (e.g., row count tracking) must be replaced with CTEs or derived columns.
- **Temporary Tables:** T-SQL temp tables (`#temp`) are not directly supported. Use CTEs or inline views in Databricks SQL.
- **Control-Flow Logic:** T-SQL procedural constructs like `IF`, `CASE` (outside SELECT), and procedural error handling (`TRY...CATCH`) are not available. All logic must be expressed as declarative SQL (e.g., CASE within SELECT).
- **Transaction Handling:** Explicit transaction blocks (`BEGIN TRAN`, `COMMIT`, `ROLLBACK`) are not supported in Databricks declarative SQL.
- **Audit Logging:** Use of `PRINT` and variable assignment for row counts is not supported. Row counts must be derived via SELECT COUNT(*) statements.
- **Data Types:** Some data types (e.g., `DATETIME`) may require conversion to Databricks-supported types (e.g., `TIMESTAMP`). Precision for numerics may need adjustment.

**4. Manual Adjustments**

- **Variable Usage:** Replace all variable declarations and assignments with CTEs or derived columns.
- **Temporary Table Logic:** Refactor temp table logic into CTEs or nested SELECTs.
- **Audit Logging:** Manual implementation required for row count logging; consider using SELECT COUNT(*) after insert.
- **Error Handling:** No direct equivalent for procedural error handling; must be handled externally or via job orchestration.
- **External Dependencies:** Ensure all dimension tables exist and are accessible in Databricks; validate business rule logic post-conversion.
- **Business Rules:** Validate that the transformation logic (e.g., income normalization) produces identical results in Databricks.

**5. Optimization Techniques**

- **Sequential CTEs:** Refactor deeply nested or multi-step logic into modular, sequential CTEs for clarity and maintainability.
- **Join Optimization:** Ensure join keys are indexed and leverage predicate pushdown by filtering early in the query.
- **Reduce Materializations:** Avoid unnecessary intermediate tables; combine transformations into fewer steps.
- **Predicate Pushdown:** Apply filters as early as possible to minimize data movement and processing.
- **Column Pruning:** Select only required columns at each stage to reduce I/O and improve performance.

**6. API Cost Consumption**

```
apiCost: 0.0040 USD
```
