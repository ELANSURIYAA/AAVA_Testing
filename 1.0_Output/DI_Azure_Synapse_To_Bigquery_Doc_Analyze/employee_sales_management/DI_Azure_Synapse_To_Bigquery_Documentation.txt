=============================================
Author: Ascendion AVA
Created on: 
Description: Generates comprehensive monthly customer sales analysis with segmentation and statistical updates
=============================================

## Procedure Overview

The sp_MonthlyCustomerSalesAnalysis stored procedure is a comprehensive business intelligence solution designed to generate detailed monthly customer sales analytics for organizational decision-making. This procedure serves as a critical component of the monthly reporting cycle, providing stakeholders with actionable insights into customer behavior, sales performance, and territory-based metrics.

The high-level goal of this procedure is to transform raw transactional data into meaningful business intelligence by aggregating sales data, calculating key performance indicators, and segmenting customers based on their purchasing patterns. The procedure processes data from multiple source tables including customer information, order transactions, product details, territorial data, and discount structures to create a unified analytical view.

The business problem this procedure solves is the need for consistent, accurate, and timely monthly sales reporting that enables management to make informed decisions about customer relationships, territory performance, and sales strategies. The value to the organization includes improved visibility into customer segments, enhanced ability to identify high-value customers, better understanding of territorial performance variations, and automated generation of standardized monthly reports that support strategic planning and operational optimization.

## Logic Details

The stored procedure implements a multi-stage data processing pipeline that begins with parameter validation and progresses through data extraction, transformation, aggregation, and final output generation. The main purpose is to create a comprehensive monthly sales analysis that combines transactional data with customer demographics and territorial information.

The procedure structure follows a systematic approach: parameter validation, temporary table creation, complex multi-table joins, data aggregation, customer segmentation logic application, and final result set generation. Key SQL operations include INNER and LEFT JOINs across six primary tables, GROUP BY aggregations for customer-level summaries, CASE statements for customer segmentation, and INSERT/UPDATE operations for persistent storage.

Input parameters include @ReportMonth (INT) for specifying the target month, @ReportYear (INT) for the target year, @TerritoryFilter (NVARCHAR(50)) for optional territory-specific filtering, @MinOrderAmount (DECIMAL(18,2)) for filtering orders below a specified threshold, and @DebugMode (BIT) for enabling detailed logging and intermediate result visibility.

The output consists of populated MonthlyCustomerSalesReport table containing aggregated customer metrics, updated CustomerStatistics table with current customer segmentation data, and optional debug information when debug mode is enabled. The procedure also generates audit trail entries and error logs for monitoring and troubleshooting purposes.

## Data Flow Details

Step 1: Parameter validation and initialization - The procedure begins by validating input parameters, ensuring @ReportMonth is between 1-12, @ReportYear is within acceptable range, and setting default values for optional parameters.

Step 2: Temporary staging table creation - A temporary table #TempSalesData is created with optimized structure to hold intermediate results, including customer identifiers, order details, calculated amounts, and derived metrics.

Step 3: Primary data extraction - Complex JOIN operations retrieve data from Customers table (customer demographics), Orders table (transaction headers), OrderDetails table (line-item specifics), Products table (product information), Territories table (geographical data), and CustomerDiscounts table (discount structures).

Step 4: Data filtering and conditional processing - Applied filters include date range filtering based on @ReportMonth and @ReportYear, territory filtering when @TerritoryFilter is specified, order amount filtering using @MinOrderAmount threshold, and active customer status validation.

Step 5: Aggregation and calculation phase - Customer-level aggregations calculate total order count, total sales amount, average order value, total quantity purchased, and discount amounts applied. Additional calculations derive metrics such as customer lifetime value indicators and purchase frequency patterns.

Step 6: Customer segmentation logic - CASE statements categorize customers into segments (Premium, Standard, Basic) based on total sales amounts, order frequency, and average order values, enabling targeted business strategies.

Step 7: Final data persistence - Aggregated results are inserted into MonthlyCustomerSalesReport table, CustomerStatistics table is updated with current segmentation data, and audit entries are logged for compliance and monitoring.

## Data Transformations

The procedure applies comprehensive data transformations to convert raw transactional data into business-ready analytics. Primary transformations include date-based filtering that converts order dates to month/year components for precise period matching, ensuring only relevant transactions are included in the analysis.

Monetary calculations transform individual order line items into meaningful customer-level metrics through summation of OrderDetails.Quantity * OrderDetails.UnitPrice, application of customer-specific discount percentages from CustomerDiscounts table, and calculation of net amounts after discount applications. These transformations ensure accurate financial reporting and customer profitability analysis.

Customer segmentation transformations apply business rules to categorize customers based on their purchasing behavior. The logic evaluates total sales amounts, order frequency, and average order values to assign customers to Premium (>$50,000 annual sales), Standard ($25,000-$50,000 annual sales), or Basic (<$25,000 annual sales) segments, enabling targeted marketing and customer service strategies.

Data cleaning transformations handle null values in optional fields, standardize territory names for consistent reporting, validate product codes and customer identifiers, and ensure data quality through constraint checking. These transformations improve data reliability and ensure consistent reporting across different time periods.

## Data Mapping

| Target Table Name | Target Column Name | Source Table Name | Source Column Name | Remarks |
|-------------------|-------------------|-------------------|-------------------|---------|
| MonthlyCustomerSalesReport | CustomerID | Customers | CustomerID | 1 to 1 mapping |
| MonthlyCustomerSalesReport | CustomerName | Customers | CustomerName | 1 to 1 mapping |
| MonthlyCustomerSalesReport | Territory | Territories | TerritoryName | 1 to 1 mapping |
| MonthlyCustomerSalesReport | TotalOrders | Orders | OrderID | Transformation (COUNT DISTINCT) |
| MonthlyCustomerSalesReport | TotalRevenue | OrderDetails | Quantity * UnitPrice * (1 - DiscountPercent/100) | Transformation (SUM with discount calculation) |
| MonthlyCustomerSalesReport | AvgOrderValue | OrderDetails | Quantity * UnitPrice * (1 - DiscountPercent/100) | Transformation (AVG with discount calculation) |
| MonthlyCustomerSalesReport | LastOrderDate | Orders | OrderDate | Transformation (MAX) |
| MonthlyCustomerSalesReport | ProductCategoryCount | Products | CategoryID | Transformation (COUNT DISTINCT) |
| MonthlyCustomerSalesReport | CustomerSegment | Multiple | TotalRevenue | Transformation (CASE logic based on revenue thresholds) |
| MonthlyCustomerSalesReport | RevenueRank | Multiple | TotalRevenue | Transformation (ROW_NUMBER partitioned by Territory) |
| MonthlyCustomerSalesReport | ReportMonth | Parameter | @ReportMonth | 1 to 1 mapping |
| MonthlyCustomerSalesReport | ReportYear | Parameter | @ReportYear | 1 to 1 mapping |
| CustomerStatistics | CustomerID | TempSalesData | CustomerID | 1 to 1 mapping |
| CustomerStatistics | LastMonthRevenue | TempSalesData | TotalRevenue | 1 to 1 mapping |
| CustomerStatistics | LastMonthOrders | TempSalesData | TotalOrders | 1 to 1 mapping |
| CustomerStatistics | LastOrderDate | TempSalesData | LastOrderDate | 1 to 1 mapping |

## Technical Complexity

| Parameter | Value |
|-----------|-------|
| Procedure Name | sp_MonthlyCustomerSalesAnalysis |
| Source Tables | 6 |
| Target Tables | 2 |
| Data Flows | 7 |
| Transformations | 15 |
| Joins and Filters | 12 |
| Variables | 7 |
| Parameters | 5 |
| Dependencies | 8 |
| Complexity Score | 85 |

## Key Outputs

The procedure generates comprehensive monthly customer sales reports that directly align with organizational business intelligence requirements. The primary output is the populated MonthlyCustomerSalesReport table containing customer-level aggregated metrics including total orders, total revenue, average order values, last order dates, product category diversity, customer segments, and revenue rankings within territories for the specified reporting period.

Secondary outputs include updated CustomerStatistics table with current customer performance metrics, including last month revenue, order counts, and most recent purchase dates. These outputs enable customer relationship management teams to identify high-value customers, track customer lifecycle stages, and implement targeted retention strategies.

The reports align with business goals by providing actionable insights for sales performance evaluation, customer segmentation strategy validation, territory performance assessment, and monthly business review processes. The customer segmentation (Premium, Standard, Basic) enables targeted marketing campaigns, while revenue rankings support territory management and sales team performance evaluation.

Output formats include structured relational data suitable for business intelligence tools integration, comprehensive audit trails logged in ProcessLog table for compliance requirements, optional debug information for technical validation when @DebugMode is enabled, and error logs for operational monitoring and troubleshooting purposes.

apiCost: 0.0875